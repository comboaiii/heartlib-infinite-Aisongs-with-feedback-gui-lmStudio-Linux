DIRECTORY SUMMARY
============================================================
Path: C:\Users\ppp\PycharmProjects\heartlib-infinite-Aisongs-with-feedback-gui-lmStudio-Linux\GROUND_TRUTH_ComboAi\AGANCY
Generated: 2026-02-14 09:07:18
Timestamps: Enabled
============================================================

SECTION 1: FILE CONTENTS
------------------------------
AGANCY/
â”‚   â”œâ”€â”€ DRAFTS/  [Mod: 2026-02-14 05:31:52]
â”‚   â”‚   â””â”€â”€ auto_save_20260214_053152.json  [Mod: 2026-02-14 05:31:52]
â”‚   â”‚       Content:
â”‚   â”‚       {
â”‚   â”‚           "topic": "song about  ai girls",
â”‚   â”‚           "lyrics": "",
â”‚   â”‚           "tags": "",
â”‚   â”‚           "timestamp": "2026-02-14T05:31:52.353139"
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”œâ”€â”€ PRODUCER_STRATEGIES/  [Mod: 2026-02-14 04:48:40]
â”‚   â”‚   â”œâ”€â”€ 1_Narrative_Concept.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â”‚   Content:
â”‚   â”‚   â”‚   {
â”‚   â”‚   â”‚       "name": "Narrative Masterpiece",
â”‚   â”‚   â”‚       "description": "A deep, cohesive story where every song is a logical step in a larger plot.",
â”‚   â”‚   â”‚       "executive_strategy": {
â”‚   â”‚   â”‚           "system_prompt": "You are a Visionary Scriptwriter. Plan an album where every song is a chapter of a cinematic story. For each track, provide a 'scene_description' that summarizes the specific plot development and emotional turning point for that chapter.",
â”‚   â”‚   â”‚           "track_count": 5
â”‚   â”‚   â”‚       },
â”‚   â”‚   â”‚       "propagation_logic": {
â”‚   â”‚   â”‚           "type": "narrative",
â”‚   â”‚   â”‚           "lyric_instruction_template": "ALBUM TITLE: {album_title}\nOVERALL STORY ARC: {album_theme}\nCURRENT CHAPTER: {track_num} of {total_tracks}\n\nSPECIFIC SCENE: {scene_description}\n\nSTORY SO FAR: {prev_context}\n\nTASK: Write the lyrics for '{track_title}'. Ensure the lyrics directly address the events in the {scene_description}. Maintain consistent character names and themes from the previous context, but advance the timeline significantly."
â”‚   â”‚   â”‚       }
â”‚   â”‚   â”‚   }
â”‚   â”‚   â”‚   
â”‚   â”‚   â”œâ”€â”€ 2_Brand_Identity_Hits.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â”‚   Content:
â”‚   â”‚   â”‚   {
â”‚   â”‚   â”‚       "name": "Brand Identity Hits",
â”‚   â”‚   â”‚       "description": "High-energy potential hits that share a consistent brand/vibe without a linear story.",
â”‚   â”‚   â”‚       "executive_strategy": {
â”‚   â”‚   â”‚           "system_prompt": "You are a Pop A&R Executive. Plan an album of unrelated hit songs that all fit a specific 'Artist Brand' defined by the user topic. For each track, provide a 'scene_description' that identifies the 'Target Radio Format' (e.g., Summer Anthem, Breakup Ballad, Club Banger).",
â”‚   â”‚   â”‚           "track_count": 3
â”‚   â”‚   â”‚       },
â”‚   â”‚   â”‚       "propagation_logic": {
â”‚   â”‚   â”‚           "type": "standalone",
â”‚   â”‚   â”‚           "lyric_instruction_template": "ALBUM BRANDING: {album_title}\nCORE VIBE: {album_theme}\nTRACK STYLE: {scene_description}\n\nTASK: Write a catchy, high-energy song titled '{track_title}'. Do NOT follow a story from the previous track. Instead, focus entirely on the {scene_description}. Use the {album_theme} to ensure the vocabulary stays consistent with the artist's brand."
â”‚   â”‚   â”‚       }
â”‚   â”‚   â”‚   }
â”‚   â”‚   â”‚   
â”‚   â”‚   â”œâ”€â”€ 3_Circadian_Ambient_Flow.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â”‚   Content:
â”‚   â”‚   â”‚   {
â”‚   â”‚   â”‚       "name": "Circadian Ambient Flow",
â”‚   â”‚   â”‚       "description": "Atmospheric tracks that transition through time (e.g., Dawn, Noon, Dusk, Midnight).",
â”‚   â”‚   â”‚       "executive_strategy": {
â”‚   â”‚   â”‚           "system_prompt": "You are a Soundscape Architect. Plan an album that follows a chronological transition of time. For each track, provide a 'scene_description' that specifies the exact Time of Day and the corresponding lighting and weather conditions.",
â”‚   â”‚   â”‚           "track_count": 4
â”‚   â”‚   â”‚       },
â”‚   â”‚   â”‚       "propagation_logic": {
â”‚   â”‚   â”‚           "type": "atmospheric",
â”‚   â”‚   â”‚           "lyric_instruction_template": "ENVIRONMENT: {album_theme}\nTIME & LIGHTING: {scene_description}\nSONIC POSITION: {track_num} of {total_tracks}\n\nTASK: Write minimal, atmospheric lyrics for '{track_title}'. Focus on sensory details (smell, light, temperature) defined in the {scene_description}. The last track felt like {prev_context}; ensure this track feels like a natural progression of time from that moment."
â”‚   â”‚   â”‚       }
â”‚   â”‚   â”‚   }
â”‚   â”‚   â”‚   
â”‚   â”‚   â””â”€â”€ 4_Mythic_Journey.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚       Content:
â”‚   â”‚       {
â”‚   â”‚           "name": "Mythic Journey",
â”‚   â”‚           "description": "An epic 5-stage arc following the Hero's Journey: Call to Adventure, Initiation, The Abyss, Transformation, and Return.",
â”‚   â”‚           "executive_strategy": {
â”‚   â”‚               "system_prompt": "You are a Master Mythologist and Storyteller. Plan a 5-track album that follows the classic Hero's Journey. For each track, provide a 'scene_description' identifying the specific mythic stage (e.g., 'Crossing the Threshold', 'The Ordeal') and the required emotional weight for that moment.",
â”‚   â”‚               "track_count": 5
â”‚   â”‚           },
â”‚   â”‚           "propagation_logic": {
â”‚   â”‚               "type": "narrative",
â”‚   â”‚               "lyric_instruction_template": "EPIC THEME: {album_theme}\nALBUM TITLE: {album_title}\n\nMYTHIC STAGE: {scene_description}\nTRACK POSITION: {track_num} of {total_tracks}\n\nTHE JOURNEY SO FAR: {prev_context}\n\nTASK: Write the lyrics for '{track_title}'. The tone must strictly adhere to the mythic stage described in the {scene_description}. If we are in 'The Abyss', the lyrics should be dark and introspective; if we are in 'The Return', they should be triumphant and wise. Ensure that specific symbols or items mentioned in the previous context ({prev_context}) reappear here to create a sense of destiny."
â”‚   â”‚           }
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”œâ”€â”€ agency_styles.py  [Mod: 2026-02-14 08:54:18]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try:
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except:
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   # agency_styles.py
â”‚   â”‚   # THEME: CYBER GREEN & DARK NOIR
â”‚   â”‚   
â”‚   â”‚   # agency_styles.py
â”‚   â”‚   # THEME: CYBER GREEN & DARK NOIR (Enhanced)
â”‚   â”‚   
â”‚   â”‚   MODERN_STYLES = """
â”‚   â”‚   /* === 0. GLOBAL & WINDOW === */
â”‚   â”‚   QMainWindow, QDialog {
â”‚   â”‚       background-color: #09090B;
â”‚   â”‚       color: #E4E4E7;
â”‚   â”‚       font-family: 'Inter', 'Segoe UI', sans-serif;
â”‚   â”‚   }
â”‚   â”‚   QWidget {
â”‚   â”‚       background-color: #09090B;
â”‚   â”‚       color: #E4E4E7;
â”‚   â”‚       font-size: 13px;
â”‚   â”‚   }
â”‚   â”‚   QFrame { border: none; }
â”‚   â”‚   
â”‚   â”‚   /* === 1. TYPOGRAPHY === */
â”‚   â”‚   QLabel { color: #A1A1AA; background: transparent; }
â”‚   â”‚   QLabel#SectionHeader {
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       font-weight: 800;
â”‚   â”‚       font-size: 11px;
â”‚   â”‚       text-transform: uppercase;
â”‚   â”‚       letter-spacing: 1.5px;
â”‚   â”‚       margin-top: 15px;
â”‚   â”‚       margin-bottom: 5px;
â”‚   â”‚       border-bottom: 2px solid #18181B;
â”‚   â”‚       padding-bottom: 3px;
â”‚   â”‚   }
â”‚   â”‚   QLabel#StatLabel {
â”‚   â”‚       color: #FFFFFF;
â”‚   â”‚       font-size: 14px;
â”‚   â”‚       font-weight: bold;
â”‚   â”‚   }
â”‚   â”‚   QLabel#StatValue {
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       font-family: 'Consolas', monospace;
â”‚   â”‚       font-size: 12px;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* === 2. INPUT FIELDS === */
â”‚   â”‚   QLineEdit, QTextEdit, QPlainTextEdit, QComboBox {
â”‚   â”‚       background-color: #121214;
â”‚   â”‚       border: 1px solid #27272A;
â”‚   â”‚       border-radius: 6px;
â”‚   â”‚       padding: 10px;
â”‚   â”‚       color: #FAFAFA;
â”‚   â”‚       selection-background-color: #00FF7F;
â”‚   â”‚       selection-color: #000000;
â”‚   â”‚   }
â”‚   â”‚   QLineEdit:focus, QTextEdit:focus, QPlainTextEdit:focus, QComboBox:focus {
â”‚   â”‚       border: 1px solid #00FF7F;
â”‚   â”‚       background-color: #000000;
â”‚   â”‚   }
â”‚   â”‚   QLineEdit::placeholder, QTextEdit::placeholder {
â”‚   â”‚       color: #52525B;
â”‚   â”‚       font-style: italic;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* === 3. BUTTONS === */
â”‚   â”‚   QPushButton {
â”‚   â”‚       padding: 10px 15px;
â”‚   â”‚       border-radius: 5px;
â”‚   â”‚       font-weight: 600;
â”‚   â”‚       border: 1px solid transparent;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#PrimaryBtn {
â”‚   â”‚       background-color: #00FF7F;
â”‚   â”‚       color: #000000;
â”‚   â”‚       font-weight: 900;
â”‚   â”‚       text-transform: uppercase;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#PrimaryBtn:hover {
â”‚   â”‚       background-color: #22C55E;
â”‚   â”‚       border: 1px solid #DCFCE7;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#SecondaryBtn {
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       border: 1px solid #3F3F46;
â”‚   â”‚       color: #E4E4E7;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#SecondaryBtn:hover {
â”‚   â”‚       border-color: #00FF7F;
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       background-color: #121214;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#IconBtn {
â”‚   â”‚       background-color: transparent;
â”‚   â”‚       color: #71717A;
â”‚   â”‚       font-size: 16px;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#IconBtn:hover { color: #00FF7F; }
â”‚   â”‚   
â”‚   â”‚   /* === 4. LISTS & TABLES (The Vault) === */
â”‚   â”‚   QListWidget, QTableWidget {
â”‚   â”‚       background-color: #050505;
â”‚   â”‚       border: 1px solid #18181B;
â”‚   â”‚       border-radius: 6px;
â”‚   â”‚       outline: none;
â”‚   â”‚   }
â”‚   â”‚   QListWidget::item, QTableWidget::item {
â”‚   â”‚       padding: 8px;
â”‚   â”‚       border-bottom: 1px solid #0D0D0F;
â”‚   â”‚       color: #A1A1AA;
â”‚   â”‚   }
â”‚   â”‚   QListWidget::item:selected, QTableWidget::item:selected {
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       border-left: 3px solid #00FF7F;
â”‚   â”‚   }
â”‚   â”‚   QListWidget::item:hover {
â”‚   â”‚       background-color: #0E0E11;
â”‚   â”‚       color: #FFFFFF;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* === 5. SCROLLBARS (Crucial for Dark Mode) === */
â”‚   â”‚   QScrollBar:vertical {
â”‚   â”‚       background: #09090B;
â”‚   â”‚       width: 8px;
â”‚   â”‚       margin: 0px;
â”‚   â”‚   }
â”‚   â”‚   QScrollBar::handle:vertical {
â”‚   â”‚       background: #27272A;
â”‚   â”‚       min-height: 20px;
â”‚   â”‚       border-radius: 4px;
â”‚   â”‚   }
â”‚   â”‚   QScrollBar::handle:vertical:hover { background: #00FF7F; }
â”‚   â”‚   QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
â”‚   â”‚   
â”‚   â”‚   /* === 6. TABS === */
â”‚   â”‚   QTabWidget::pane { border: 1px solid #18181B; }
â”‚   â”‚   QTabBar::tab {
â”‚   â”‚       background: #09090B;
â”‚   â”‚       color: #71717A;
â”‚   â”‚       padding: 8px 20px;
â”‚   â”‚       border-bottom: 2px solid transparent;
â”‚   â”‚       font-weight: bold;
â”‚   â”‚       text-transform: uppercase;
â”‚   â”‚   }
â”‚   â”‚   QTabBar::tab:selected {
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       border-bottom: 2px solid #00FF7F;
â”‚   â”‚   }
â”‚   â”‚   QTabBar::tab:hover { color: #FFFFFF; }
â”‚   â”‚   
â”‚   â”‚   /* === 7. SIDEBAR SPECIFIC === */
â”‚   â”‚   QFrame#Sidebar {
â”‚   â”‚       background-color: #0C0C0E;
â”‚   â”‚       border-right: 1px solid #18181B;
â”‚   â”‚   }
â”‚   â”‚   QFrame#Inspector {
â”‚   â”‚       background-color: #0C0C0E;
â”‚   â”‚       border-left: 1px solid #18181B;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* === 8. PROGRESS BAR === */
â”‚   â”‚   QProgressBar {
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       border: none;
â”‚   â”‚       height: 4px;
â”‚   â”‚       text-align: center;
â”‚   â”‚   }
â”‚   â”‚   QProgressBar::chunk {
â”‚   â”‚       background-color: #00FF7F;
â”‚   â”‚       border-radius: 2px;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* === 9. SLIDERS === */
â”‚   â”‚   QSlider::groove:horizontal {
â”‚   â”‚       height: 4px;
â”‚   â”‚       background: #27272A;
â”‚   â”‚       border-radius: 2px;
â”‚   â”‚   }
â”‚   â”‚   QSlider::handle:horizontal {
â”‚   â”‚       background: #00FF7F;
â”‚   â”‚       width: 14px;
â”‚   â”‚       height: 14px;
â”‚   â”‚       margin: -5px 0;
â”‚   â”‚       border-radius: 7px;
â”‚   â”‚   }
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”œâ”€â”€ Album_Post_Processor.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   import os
â”‚   â”‚   import json
â”‚   â”‚   import numpy as np
â”‚   â”‚   import scipy.io.wavfile
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from datetime import datetime
â”‚   â”‚   from colorama import Fore, Style, init
â”‚   â”‚   
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class AlbumPostProcessor:
â”‚   â”‚       def __init__(self, album_path):
â”‚   â”‚           self.album_path = Path(album_path)
â”‚   â”‚           self.dist_path = self.album_path / "DISTRIBUTION_READY"
â”‚   â”‚           self.dist_path.mkdir(exist_ok=True)
â”‚   â”‚   
â”‚   â”‚       def _load_wav(self, path):
â”‚   â”‚           rate, data = scipy.io.wavfile.read(path)
â”‚   â”‚           # Convert to float32 for processing
â”‚   â”‚           if data.dtype == np.int16:
â”‚   â”‚               data = data.astype(np.float32) / 32768.0
â”‚   â”‚           return rate, data
â”‚   â”‚   
â”‚   â”‚       def _save_wav(self, path, rate, data):
â”‚   â”‚           # Convert back to int16
â”‚   â”‚           data_int16 = np.int16(data * 32767)
â”‚   â”‚           scipy.io.wavfile.write(path, rate, data_int16)
â”‚   â”‚   
â”‚   â”‚       def normalize_audio(self, audio_data, target_dB=-1.0):
â”‚   â”‚           """
â”‚   â”‚           Applies Peak Normalization so all tracks have consistent volume.
â”‚   â”‚           """
â”‚   â”‚           peak = np.max(np.abs(audio_data))
â”‚   â”‚           if peak == 0: return audio_data
â”‚   â”‚   
â”‚   â”‚           # Calculate scalar
â”‚   â”‚           scalar = 10 ** (target_dB / 20) / peak
â”‚   â”‚           return audio_data * scalar
â”‚   â”‚   
â”‚   â”‚       def generate_analytics(self, track_jsons):
â”‚   â”‚           """
â”‚   â”‚           Compiles the 'further analytics' requested.
â”‚   â”‚           """
â”‚   â”‚           total_time = 0
â”‚   â”‚           vocab_set = set()
â”‚   â”‚           genre_distribution = {}
â”‚   â”‚   
â”‚   â”‚           for tm in track_jsons:
â”‚   â”‚               # Time
â”‚   â”‚               dur = tm.get('configuration', {}).get('duration_sec', 0)
â”‚   â”‚               total_time += dur
â”‚   â”‚   
â”‚   â”‚               # Vocab (Rough estimate from lyrics)
â”‚   â”‚               lyrics = tm.get('configuration', {}).get('input_prompt', {}).get('lyrics', "")
â”‚   â”‚               words = lyrics.lower().split()
â”‚   â”‚               vocab_set.update(words)
â”‚   â”‚   
â”‚   â”‚               # Genres
â”‚   â”‚               tags = tm.get('configuration', {}).get('input_prompt', {}).get('tags', [])
â”‚   â”‚               for t in tags:
â”‚   â”‚                   genre_distribution[t] = genre_distribution.get(t, 0) + 1
â”‚   â”‚   
â”‚   â”‚           return {
â”‚   â”‚               "total_runtime_seconds": total_time,
â”‚   â”‚               "total_runtime_formatted": f"{total_time // 60}m {total_time % 60}s",
â”‚   â”‚               "vocabulary_size": len(vocab_set),
â”‚   â”‚               "genre_dominance": dict(sorted(genre_distribution.items(), key=lambda item: item[1], reverse=True)),
â”‚   â”‚               "track_count": len(track_jsons),
â”‚   â”‚               "processed_date": datetime.now().isoformat()
â”‚   â”‚           }
â”‚   â”‚   
â”‚   â”‚       def process_album(self):
â”‚   â”‚           print(f"\n{Fore.CYAN}ğŸ§ STARTING POST-PRODUCTION: {self.album_path.name}")
â”‚   â”‚   
â”‚   â”‚           # Find all generated JSONs
â”‚   â”‚           json_files = sorted(list(self.album_path.glob("*.json")))
â”‚   â”‚   
â”‚   â”‚           # Filter out manifest files (only want song ledgers)
â”‚   â”‚           track_ledgers = []
â”‚   â”‚           for j in json_files:
â”‚   â”‚               if "manifest" in j.name or "MASTER" in j.name: continue
â”‚   â”‚   
â”‚   â”‚               try:
â”‚   â”‚                   with open(j, 'r') as f:
â”‚   â”‚                       data = json.load(f)
â”‚   â”‚                       # Check if it looks like a song ledger
â”‚   â”‚                       if 'provenance' in data:
â”‚   â”‚                           track_ledgers.append((j, data))
â”‚   â”‚               except:
â”‚   â”‚                   pass
â”‚   â”‚   
â”‚   â”‚           if not track_ledgers:
â”‚   â”‚               print(f"{Fore.RED}âŒ No track ledgers found via JSON scan.")
â”‚   â”‚               return
â”‚   â”‚   
â”‚   â”‚           print(f"{Fore.GREEN}âœ… Found {len(track_ledgers)} tracks. Mastering...")
â”‚   â”‚   
â”‚   â”‚           cleaned_metadata = []
â”‚   â”‚   
â”‚   â”‚           # PROCESSING LOOP
â”‚   â”‚           for idx, (json_path, data) in enumerate(track_ledgers):
â”‚   â”‚               track_num = idx + 1
â”‚   â”‚   
â”‚   â”‚               # 1. Identify Audio File
â”‚   â”‚               wav_path = json_path.with_suffix('.wav')
â”‚   â”‚               if not wav_path.exists():
â”‚   â”‚                   print(f"{Fore.RED}   âš ï¸ Missing Audio for: {json_path.name}")
â”‚   â”‚                   continue
â”‚   â”‚   
â”‚   â”‚               title = data.get('configuration', {}).get('input_prompt', {}).get('topic', f"Untitled_{track_num}")
â”‚   â”‚               safe_title = "".join([c for c in title if c.isalnum() or c in " _-"]).strip().replace(" ", "_")
â”‚   â”‚   
â”‚   â”‚               print(f"{Fore.LIGHTBLACK_EX}   ğŸšï¸  Mastering Track {track_num}: {title}")
â”‚   â”‚   
â”‚   â”‚               # 2. Load & Normalize Audio
â”‚   â”‚               try:
â”‚   â”‚                   rate, audio = self._load_wav(wav_path)
â”‚   â”‚                   norm_audio = self.normalize_audio(audio)
â”‚   â”‚   
â”‚   â”‚                   # 3. Save to Distribution Folder (Clean Name)
â”‚   â”‚                   final_filename = f"{track_num:02d}_{safe_title}.wav"
â”‚   â”‚                   final_path = self.dist_path / final_filename
â”‚   â”‚   
â”‚   â”‚                   self._save_wav(final_path, rate, norm_audio)
â”‚   â”‚   
â”‚   â”‚               except Exception as e:
â”‚   â”‚                   print(f"{Fore.RED}      Error processing audio: {e}")
â”‚   â”‚                   continue
â”‚   â”‚   
â”‚   â”‚               # 4. Append to Metadata List
â”‚   â”‚               cleaned_metadata.append(data)
â”‚   â”‚   
â”‚   â”‚           # 5. Generate Master Analytics
â”‚   â”‚           analytics = self.generate_analytics(cleaned_metadata)
â”‚   â”‚   
â”‚   â”‚           # 6. Save Master JSON
â”‚   â”‚           master_release = {
â”‚   â”‚               "album_name": self.album_path.name.replace("ALBUM_", "").replace("_", " "),
â”‚   â”‚               "analytics": analytics,
â”‚   â”‚               "tracks": cleaned_metadata
â”‚   â”‚           }
â”‚   â”‚   
â”‚   â”‚           with open(self.dist_path / "MASTER_RELEASE_LOG.json", "w") as f:
â”‚   â”‚               json.dump(master_release, f, indent=4)
â”‚   â”‚   
â”‚   â”‚           print(f"\n{Fore.GREEN}âœ¨ ALBUM MASTERED SUCCESSFULLY!")
â”‚   â”‚           print(f"ğŸ“‚ Output: {self.dist_path}")
â”‚   â”‚           print(f"ğŸ“Š Stats: {analytics['total_runtime_formatted']} | {analytics['vocabulary_size']} unique words")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # --- STANDALONE RUNNER ---
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       from orphio_config import conf
â”‚   â”‚   
â”‚   â”‚       # Simple menu to pick an album to process
â”‚   â”‚       albums = [d for d in conf.OUTPUT_DIR.iterdir() if d.is_dir() and "ALBUM_" in d.name]
â”‚   â”‚   
â”‚   â”‚       if not albums:
â”‚   â”‚           print(f"{Fore.RED}No albums found in {conf.OUTPUT_DIR}")
â”‚   â”‚       else:
â”‚   â”‚           print(f"{Fore.WHITE}Select Album to Master:")
â”‚   â”‚           for i, alb in enumerate(albums):
â”‚   â”‚               print(f"[{i + 1}] {alb.name}")
â”‚   â”‚   
â”‚   â”‚           choice = int(input("Number: ")) - 1
â”‚   â”‚   
â”‚   â”‚           processor = AlbumPostProcessor(albums[choice])
â”‚   â”‚           processor.process_album()
â”‚   â”‚   
â”‚   â”œâ”€â”€ Blueprint_Executor.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚   
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try:
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except:
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   import json
â”‚   â”‚   import re
â”‚   â”‚   import time
â”‚   â”‚   import os
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from colorama import Fore, Style, init
â”‚   â”‚   
â”‚   â”‚   from orphio_config import conf
â”‚   â”‚   from lmstudio_controler import LMStudioController
â”‚   â”‚   from orphio_engine import OrphioEngine
â”‚   â”‚   
â”‚   â”‚   # Initialize colorama for Green/Black console output
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ProducerBlueprintEngine:
â”‚   â”‚       def __init__(self):
â”‚   â”‚           self.lms = LMStudioController(conf.LM_STUDIO_URL)
â”‚   â”‚           self.engine = OrphioEngine(log_callback=print)
â”‚   â”‚           # Point to the strategies folder
â”‚   â”‚           self.strategies_path = Path(__file__).parent / "PRODUCER_STRATEGIES"
â”‚   â”‚           self.strategies_path.mkdir(parents=True, exist_ok=True)
â”‚   â”‚   
â”‚   â”‚       def list_producers(self):
â”‚   â”‚           """
â”‚   â”‚           DYNAMIC SCANNER: Scans the PRODUCER_STRATEGIES folder.
â”‚   â”‚           Ensures all .json files (1, 2, 3, 4) are loaded and sorted.
â”‚   â”‚           """
â”‚   â”‚           # Sort files by name so 1_ comes before 4_
â”‚   â”‚           files = sorted(list(self.strategies_path.glob("*.json")))
â”‚   â”‚           producers_data = []
â”‚   â”‚   
â”‚   â”‚           for f in files:
â”‚   â”‚               try:
â”‚   â”‚                   with open(f, 'r', encoding='utf-8') as j:
â”‚   â”‚                       data = json.load(j)
â”‚   â”‚                       producers_data.append({
â”‚   â”‚                           "path": f,
â”‚   â”‚                           "name": data.get("name", f.stem.replace("_", " ")),
â”‚   â”‚                           "desc": data.get("description", "Dynamic Strategy"),
â”‚   â”‚                           "file_id": f.stem
â”‚   â”‚                       })
â”‚   â”‚               except Exception as e:
â”‚   â”‚                   print(f"{Fore.RED}âš ï¸ Error loading blueprint {f.name}: {e}")
â”‚   â”‚                   continue
â”‚   â”‚   
â”‚   â”‚           return producers_data
â”‚   â”‚   
â”‚   â”‚       def load_blueprint(self, filepath):
â”‚   â”‚           """Loads a specific JSON blueprint file."""
â”‚   â”‚           with open(filepath, 'r', encoding='utf-8') as f:
â”‚   â”‚               return json.load(f)
â”‚   â”‚   
â”‚   â”‚       def _extract_json_from_response(self, text):
â”‚   â”‚           """Helper to extract JSON from LLM markdown responses."""
â”‚   â”‚           try:
â”‚   â”‚               clean_text = text.replace("```json", "").replace("```", "").strip()
â”‚   â”‚               return json.loads(clean_text)
â”‚   â”‚           except:
â”‚   â”‚               match = re.search(r'\{.*\}', text, re.DOTALL)
â”‚   â”‚               if match:
â”‚   â”‚                   try:
â”‚   â”‚                       return json.loads(match.group(0))
â”‚   â”‚                   except:
â”‚   â”‚                       return None
â”‚   â”‚           return None
â”‚   â”‚   
â”‚   â”‚       def stage_1_draft_content(self, blueprint, user_topic, user_track_count=None, tag_mode="AI", manual_tags=None):
â”‚   â”‚           """
â”‚   â”‚           PHASE 1: Planning and Lyric Generation.
â”‚   â”‚           Propagates Album Title, Theme, and Sequence Context to every song.
â”‚   â”‚           """
â”‚   â”‚           print(f"\n{Fore.GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
â”‚   â”‚           print(f"{Fore.GREEN}â•‘  ğŸ“ PHASE 1: CONTENT DRAFTING & PROPAGATION   â•‘")
â”‚   â”‚           print(f"{Fore.GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
â”‚   â”‚   
â”‚   â”‚           # 1. Determine Track Count
â”‚   â”‚           target_count = blueprint['executive_strategy'].get('track_count', 3)
â”‚   â”‚           if user_track_count and user_track_count > 0:
â”‚   â”‚               target_count = user_track_count
â”‚   â”‚   
â”‚   â”‚           # 2. Executive Producer Plans the Album
â”‚   â”‚           exec_prompt = (
â”‚   â”‚               f"{blueprint['executive_strategy']['system_prompt']}\n"
â”‚   â”‚               f"USER CONCEPT: {user_topic}\n"
â”‚   â”‚               f"MANDATORY: Plan exactly {target_count} songs.\n"
â”‚   â”‚               "FORMAT: JSON with 'album_title', 'album_theme_summary', and 'tracklist' (array of objects with 'title' and 'scene_description')."
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚           print(f"{Fore.GREEN}ğŸ§  [PRODUCER] Blueprinting the album structure...")
â”‚   â”‚           plan_raw = self.lms.chat("You are a Master Executive Music Producer.", exec_prompt)
â”‚   â”‚           plan = self._extract_json_from_response(plan_raw)
â”‚   â”‚   
â”‚   â”‚           if not plan:
â”‚   â”‚               print(f"{Fore.RED}âŒ Failed to plan album. LLM output was not valid JSON.")
â”‚   â”‚               return None
â”‚   â”‚   
â”‚   â”‚           album_title = plan.get('album_title', 'Untitled Project')
â”‚   â”‚           album_theme = plan.get('album_theme_summary', user_topic)
â”‚   â”‚           track_list = plan.get('tracklist', [])
â”‚   â”‚           total_tracks = len(track_list)
â”‚   â”‚   
â”‚   â”‚           print(f"{Fore.GREEN}âœ… [PLAN READY] {album_title} | {total_tracks} tracks")
â”‚   â”‚   
â”‚   â”‚           # Create Album Directory
â”‚   â”‚           safe_album_title = "".join([c for c in album_title if c.isalnum() or c in " _-"]).strip().replace(" ", "_")
â”‚   â”‚           album_dir = conf.OUTPUT_DIR / f"ALBUM_{safe_album_title}"
â”‚   â”‚           album_dir.mkdir(parents=True, exist_ok=True)
â”‚   â”‚   
â”‚   â”‚           # Save Manifest for reference
â”‚   â”‚           with open(album_dir / "00_ALBUM_MANIFEST.json", "w", encoding='utf-8') as f:
â”‚   â”‚               json.dump(plan, f, indent=4)
â”‚   â”‚   
â”‚   â”‚           context_history = []
â”‚   â”‚   
â”‚   â”‚           # 3. Iterative Generation Loop
â”‚   â”‚           for i, track in enumerate(track_list):
â”‚   â”‚               current_num = i + 1
â”‚   â”‚               t_title = track.get('title', f"Track {current_num}")
â”‚   â”‚               t_description = track.get('scene_description', "Atmospheric development.")
â”‚   â”‚   
â”‚   â”‚               print(f"\n{Fore.GREEN}âœï¸  Drafting Song {current_num}/{total_tracks}: {t_title}")
â”‚   â”‚   
â”‚   â”‚               # Prepare Sequence Context (Narrative Flow)
â”‚   â”‚               prev_context_text = context_history[-1]['summary'] if context_history else "This is the opening track."
â”‚   â”‚   
â”‚   â”‚               # Inject Blueprint Logic
â”‚   â”‚               template = blueprint['propagation_logic']['lyric_instruction_template']
â”‚   â”‚               smart_prompt = template.replace("{album_title}", album_title) \
â”‚   â”‚                   .replace("{album_theme}", album_theme) \
â”‚   â”‚                   .replace("{track_title}", t_title) \
â”‚   â”‚                   .replace("{track_num}", str(current_num)) \
â”‚   â”‚                   .replace("{total_tracks}", str(total_tracks)) \
â”‚   â”‚                   .replace("{scene_description}", t_description) \
â”‚   â”‚                   .replace("{prev_context}", prev_context_text)
â”‚   â”‚   
â”‚   â”‚               # 4. Generate Lyrics
â”‚   â”‚               lyrics = self.lms.chat(conf.PROMPT_WRITER, smart_prompt)
â”‚   â”‚               lyrics = self.engine._enforce_tag_schema(lyrics)
â”‚   â”‚   
â”‚   â”‚               # 5. Generate Tags
â”‚   â”‚               if tag_mode == "MANUAL":
â”‚   â”‚                   tags = manual_tags if manual_tags else ["Electronic"]
â”‚   â”‚               else:
â”‚   â”‚                   try:
â”‚   â”‚                       print(f"{Fore.GREEN}   ğŸ·ï¸  Analyzing genre and vibe...")
â”‚   â”‚                       tags_raw = self.lms.chat(conf.PROMPT_TAGGER, f"Album: {album_title}\nLyrics: {lyrics}", temp=0.2)
â”‚   â”‚                       tags = self.engine._clean_tags_list(tags_raw)
â”‚   â”‚                   except Exception:
â”‚   â”‚                       tags = ["melodic", "modern", album_title.split()[0]]
â”‚   â”‚   
â”‚   â”‚               print(f"{Fore.WHITE}   Final Style: {', '.join(tags)}")
â”‚   â”‚   
â”‚   â”‚               # 6. Save Draft Ledger
â”‚   â”‚               draft_data = {
â”‚   â”‚                   "track_number": current_num,
â”‚   â”‚                   "total_tracks": total_tracks,
â”‚   â”‚                   "album_title": album_title,
â”‚   â”‚                   "title": t_title,
â”‚   â”‚                   "status": "DRAFT_READY",
â”‚   â”‚                   "parameters": {
â”‚   â”‚                       "topic": t_title,
â”‚   â”‚                       "lyrics": lyrics,
â”‚   â”‚                       "tags": tags,
â”‚   â”‚                       "scene": t_description
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚   
â”‚   â”‚               safe_title = "".join([c for c in t_title if c.isalnum() or c in " _-"]).replace(" ", "_")
â”‚   â”‚               fname = f"{current_num:02d}_{safe_title}_DRAFT.json"
â”‚   â”‚               with open(album_dir / fname, "w", encoding='utf-8') as f:
â”‚   â”‚                   json.dump(draft_data, f, indent=4)
â”‚   â”‚   
â”‚   â”‚               # Update context for the next song (first 200 chars of current lyrics)
â”‚   â”‚               summary = lyrics.replace("\n", " ")
â”‚   â”‚               context_history.append({"summary": summary[:200] + "..."})
â”‚   â”‚               time.sleep(1.0)
â”‚   â”‚   
â”‚   â”‚           return album_dir
â”‚   â”‚   
â”‚   â”‚       def stage_2_batch_render(self, album_dir, user_duration, cfg_scale=1.5):
â”‚   â”‚           """
â”‚   â”‚           PHASE 2: Batch Audio Rendering.
â”‚   â”‚           """
â”‚   â”‚           album_dir = Path(album_dir)
â”‚   â”‚           drafts = sorted(list(album_dir.glob("*_DRAFT.json")))
â”‚   â”‚   
â”‚   â”‚           print(f"\n{Fore.GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
â”‚   â”‚           print(f"{Fore.GREEN}â•‘  ğŸ”Š PHASE 2: BATCH AUDIO RENDERING             â•‘")
â”‚   â”‚           print(f"{Fore.GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
â”‚   â”‚   
â”‚   â”‚           for idx, json_file in enumerate(drafts):
â”‚   â”‚               try:
â”‚   â”‚                   with open(json_file, 'r', encoding='utf-8') as f:
â”‚   â”‚                       data = json.load(f)
â”‚   â”‚   
â”‚   â”‚                   params = data.get("parameters", {})
â”‚   â”‚                   self.engine.free_memory()
â”‚   â”‚   
â”‚   â”‚                   print(f"{Fore.GREEN}ğŸš€ Rendering [{idx + 1}/{len(drafts)}]: {data.get('title')}")
â”‚   â”‚   
â”‚   â”‚                   wav_path, ledger = self.engine.render_audio_stage(
â”‚   â”‚                       topic=data.get("title"),
â”‚   â”‚                       lyrics=params.get("lyrics"),
â”‚   â”‚                       tags=params.get("tags"),
â”‚   â”‚                       duration_s=user_duration,
â”‚   â”‚                       cfg=cfg_scale,
â”‚   â”‚                       temp=1.0
â”‚   â”‚                   )
â”‚   â”‚   
â”‚   â”‚                   # Rename to final clean naming convention
â”‚   â”‚                   dest_wav_name = json_file.name.replace("_DRAFT.json", ".wav")
â”‚   â”‚                   dest_json_name = json_file.name.replace("_DRAFT.json", ".json")
â”‚   â”‚   
â”‚   â”‚                   if Path(wav_path).exists():
â”‚   â”‚                       Path(wav_path).rename(album_dir / dest_wav_name)
â”‚   â”‚                       ledger_source = Path(wav_path).with_suffix('.json')
â”‚   â”‚                       if ledger_source.exists():
â”‚   â”‚                           ledger_source.rename(album_dir / dest_json_name)
â”‚   â”‚   
â”‚   â”‚                   os.remove(json_file)  # Remove draft once rendered
â”‚   â”‚                   print(f"{Fore.GREEN}   âœ… Finished Production: {dest_wav_name}")
â”‚   â”‚   
â”‚   â”‚               except Exception as e:
â”‚   â”‚                   print(f"{Fore.RED}âŒ Batch Render Error on {json_file.name}: {e}")
â”‚   â”‚   
â”‚   â”‚       def execute_album(self, blueprint, user_topic, user_duration=120, user_track_count=None):
â”‚   â”‚           """Full Pipeline Orchestrator."""
â”‚   â”‚           album_path = self.stage_1_draft_content(blueprint, user_topic, user_track_count)
â”‚   â”‚           if album_path:
â”‚   â”‚               self.stage_2_batch_render(album_path, user_duration)
â”‚   â”‚               return album_path
â”‚   â”‚           return None
â”‚   â”‚   
â”‚   â”œâ”€â”€ EnhancedModelScanner.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   ENHANCED LM STUDIO MODEL SCANNER
â”‚   â”‚   =================================
â”‚   â”‚   Scans LM Studio for available models and analyzes their capabilities
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   import requests
â”‚   â”‚   import json
â”‚   â”‚   import re
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from typing import Dict, List, Tuple
â”‚   â”‚   from colorama import Fore, init
â”‚   â”‚   
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class EnhancedModelScanner:
â”‚   â”‚       """Enhanced scanner for LM Studio models with capability detection"""
â”‚   â”‚       
â”‚   â”‚       # Model capability patterns
â”‚   â”‚       CAPABILITY_PATTERNS = {
â”‚   â”‚           "reasoning": [r"reasoning", r"deepseek", r"r1", r"cot", r"think", r"distill"],
â”‚   â”‚           "creative": [r"story", r"creative", r"writer", r"lumimaid", r"mythomax"],
â”‚   â”‚           "uncensored": [r"uncensored", r"abliterated", r"dolphin", r"hermes", r"psyfighter"],
â”‚   â”‚           "code": [r"code", r"coder", r"deepseek-coder", r"wizard"],
â”‚   â”‚           "multilingual": [r"multilingual", r"qwen", r"aya"],
â”‚   â”‚           "instruct": [r"instruct", r"chat", r"hermes"],
â”‚   â”‚           "fast": [r"fast", r"speed", r"tiny", r"small"],
â”‚   â”‚           "large": [r"70b", r"72b", r"405b", r"mixtral"]
â”‚   â”‚       }
â”‚   â”‚       
â”‚   â”‚       def __init__(self, base_url="http://localhost:1234/v1"):
â”‚   â”‚           self.base_url = base_url.rstrip('/')
â”‚   â”‚       
â”‚   â”‚       def check_connection(self) -> Tuple[bool, str]:
â”‚   â”‚           """Check if LM Studio is running and accessible"""
â”‚   â”‚           try:
â”‚   â”‚               response = requests.get(f"{self.base_url}/models", timeout=3)
â”‚   â”‚               if response.status_code == 200:
â”‚   â”‚                   return True, "Connected to LM Studio"
â”‚   â”‚               return False, f"HTTP Error {response.status_code}"
â”‚   â”‚           except requests.exceptions.ConnectionError:
â”‚   â”‚               return False, "Connection refused - Is LM Studio server running?"
â”‚   â”‚           except Exception as e:
â”‚   â”‚               return False, str(e)
â”‚   â”‚       
â”‚   â”‚       def get_loaded_model(self) -> Dict:
â”‚   â”‚           """Get currently loaded model information"""
â”‚   â”‚           try:
â”‚   â”‚               response = requests.get(f"{self.base_url}/models", timeout=3)
â”‚   â”‚               if response.status_code == 200:
â”‚   â”‚                   data = response.json()
â”‚   â”‚                   if data.get('data') and len(data['data']) > 0:
â”‚   â”‚                       model = data['data'][0]
â”‚   â”‚                       return {
â”‚   â”‚                           'id': model.get('id', 'unknown'),
â”‚   â”‚                           'owned_by': model.get('owned_by', 'unknown'),
â”‚   â”‚                           'created': model.get('created', 0),
â”‚   â”‚                           'object': model.get('object', 'model'),
â”‚   â”‚                           'status': 'loaded'
â”‚   â”‚                       }
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print(f"{Fore.RED}Error getting loaded model: {e}")
â”‚   â”‚           
â”‚   â”‚           return None
â”‚   â”‚       
â”‚   â”‚       def detect_capabilities(self, model_id: str) -> List[str]:
â”‚   â”‚           """Detect model capabilities based on name patterns"""
â”‚   â”‚           model_lower = model_id.lower()
â”‚   â”‚           capabilities = []
â”‚   â”‚           
â”‚   â”‚           for capability, patterns in self.CAPABILITY_PATTERNS.items():
â”‚   â”‚               if any(re.search(pattern, model_lower) for pattern in patterns):
â”‚   â”‚                   capabilities.append(capability)
â”‚   â”‚           
â”‚   â”‚           # Add defaults if nothing detected
â”‚   â”‚           if not capabilities:
â”‚   â”‚               capabilities.append("general")
â”‚   â”‚           
â”‚   â”‚           return capabilities
â”‚   â”‚       
â”‚   â”‚       def estimate_size(self, model_id: str) -> str:
â”‚   â”‚           """Estimate model size from name"""
â”‚   â”‚           model_lower = model_id.lower()
â”‚   â”‚           
â”‚   â”‚           # Look for size indicators
â”‚   â”‚           if any(x in model_lower for x in ['70b', '72b']):
â”‚   â”‚               return "~40-50GB"
â”‚   â”‚           elif any(x in model_lower for x in ['30b', '34b']):
â”‚   â”‚               return "~20-25GB"
â”‚   â”‚           elif any(x in model_lower for x in ['13b', '14b']):
â”‚   â”‚               return "~8-10GB"
â”‚   â”‚           elif any(x in model_lower for x in ['7b', '8b']):
â”‚   â”‚               return "~4-6GB"
â”‚   â”‚           elif any(x in model_lower for x in ['3b']):
â”‚   â”‚               return "~2-3GB"
â”‚   â”‚           elif any(x in model_lower for x in ['1b']):
â”‚   â”‚               return "~1GB"
â”‚   â”‚           else:
â”‚   â”‚               return "Unknown"
â”‚   â”‚       
â”‚   â”‚       def get_model_info(self, model_id: str) -> Dict:
â”‚   â”‚           """Get comprehensive model information"""
â”‚   â”‚           capabilities = self.detect_capabilities(model_id)
â”‚   â”‚           size = self.estimate_size(model_id)
â”‚   â”‚           
â”‚   â”‚           # Determine optimal use case
â”‚   â”‚           if "reasoning" in capabilities:
â”‚   â”‚               use_case = "Complex lyrics, narrative coherence"
â”‚   â”‚           elif "creative" in capabilities:
â”‚   â”‚               use_case = "Creative lyrics, storytelling"
â”‚   â”‚           elif "uncensored" in capabilities:
â”‚   â”‚               use_case = "Unrestricted content, mature themes"
â”‚   â”‚           elif "fast" in capabilities:
â”‚   â”‚               use_case = "Quick generation, drafting"
â”‚   â”‚           else:
â”‚   â”‚               use_case = "General purpose lyrics"
â”‚   â”‚           
â”‚   â”‚           return {
â”‚   â”‚               'id': model_id,
â”‚   â”‚               'capabilities': capabilities,
â”‚   â”‚               'estimated_size': size,
â”‚   â”‚               'recommended_use': use_case,
â”‚   â”‚               'quality_rating': self._estimate_quality(model_id, capabilities)
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚       def _estimate_quality(self, model_id: str, capabilities: List[str]) -> str:
â”‚   â”‚           """Estimate model quality tier"""
â”‚   â”‚           model_lower = model_id.lower()
â”‚   â”‚           
â”‚   â”‚           # High-end models
â”‚   â”‚           if any(x in model_lower for x in ['70b', '72b', 'qwen-2.5']):
â”‚   â”‚               return "Excellent"
â”‚   â”‚           
â”‚   â”‚           # Mid-tier
â”‚   â”‚           elif any(x in model_lower for x in ['30b', '34b', 'mixtral']):
â”‚   â”‚               return "Very Good"
â”‚   â”‚           
â”‚   â”‚           # Standard
â”‚   â”‚           elif any(x in model_lower for x in ['13b', '14b']):
â”‚   â”‚               return "Good"
â”‚   â”‚           
â”‚   â”‚           # Small but capable
â”‚   â”‚           elif "reasoning" in capabilities or "creative" in capabilities:
â”‚   â”‚               return "Good"
â”‚   â”‚           
â”‚   â”‚           # Basic
â”‚   â”‚           else:
â”‚   â”‚               return "Adequate"
â”‚   â”‚       
â”‚   â”‚       def scan_and_report(self) -> Dict:
â”‚   â”‚           """Perform full scan and generate report"""
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}")
â”‚   â”‚           print(f"{Fore.CYAN}  LM STUDIO MODEL SCANNER - Enhanced Edition")
â”‚   â”‚           print(f"{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚           
â”‚   â”‚           # Check connection
â”‚   â”‚           ok, msg = self.check_connection()
â”‚   â”‚           print(f"Connection Status: ", end="")
â”‚   â”‚           if ok:
â”‚   â”‚               print(f"{Fore.GREEN}âœ“ {msg}")
â”‚   â”‚           else:
â”‚   â”‚               print(f"{Fore.RED}âœ— {msg}")
â”‚   â”‚               return {'status': 'error', 'message': msg}
â”‚   â”‚           
â”‚   â”‚           # Get loaded model
â”‚   â”‚           loaded_model = self.get_loaded_model()
â”‚   â”‚           
â”‚   â”‚           if not loaded_model:
â”‚   â”‚               print(f"{Fore.YELLOW}No model currently loaded")
â”‚   â”‚               return {'status': 'no_model', 'message': 'No model loaded'}
â”‚   â”‚           
â”‚   â”‚           model_id = loaded_model['id']
â”‚   â”‚           print(f"\n{Fore.WHITE}Currently Loaded Model:")
â”‚   â”‚           print(f"{Fore.CYAN}  ID: {Fore.WHITE}{model_id}")
â”‚   â”‚           
â”‚   â”‚           # Analyze model
â”‚   â”‚           info = self.get_model_info(model_id)
â”‚   â”‚           
â”‚   â”‚           print(f"{Fore.CYAN}  Size: {Fore.WHITE}{info['estimated_size']}")
â”‚   â”‚           print(f"{Fore.CYAN}  Quality: {Fore.WHITE}{info['quality_rating']}")
â”‚   â”‚           print(f"{Fore.CYAN}  Best For: {Fore.WHITE}{info['recommended_use']}")
â”‚   â”‚           
â”‚   â”‚           # Capabilities
â”‚   â”‚           print(f"\n{Fore.WHITE}Detected Capabilities:")
â”‚   â”‚           for cap in info['capabilities']:
â”‚   â”‚               icon = {
â”‚   â”‚                   'reasoning': 'ğŸ§ ',
â”‚   â”‚                   'creative': 'âœ¨',
â”‚   â”‚                   'uncensored': 'ğŸ”“',
â”‚   â”‚                   'code': 'ğŸ’»',
â”‚   â”‚                   'fast': 'âš¡',
â”‚   â”‚                   'large': 'ğŸ˜',
â”‚   â”‚                   'instruct': 'ğŸ“‹',
â”‚   â”‚                   'multilingual': 'ğŸŒ',
â”‚   â”‚                   'general': 'ğŸ¤–'
â”‚   â”‚               }.get(cap, 'â€¢')
â”‚   â”‚               print(f"  {icon} {cap.capitalize()}")
â”‚   â”‚           
â”‚   â”‚           # Recommendations
â”‚   â”‚           print(f"\n{Fore.YELLOW}Recommendations for Music Production:")
â”‚   â”‚           if "reasoning" in info['capabilities']:
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ Excellent for narrative albums")
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ Good at maintaining story coherence")
â”‚   â”‚           
â”‚   â”‚           if "creative" in info['capabilities']:
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ Great for original lyrics")
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ Good at metaphors and imagery")
â”‚   â”‚           
â”‚   â”‚           if "fast" in info['capabilities']:
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ Quick draft generation")
â”‚   â”‚               print(f"  {Fore.YELLOW}âš  May need more editing")
â”‚   â”‚           
â”‚   â”‚           if info['quality_rating'] in ['Excellent', 'Very Good']:
â”‚   â”‚               print(f"  {Fore.GREEN}âœ“ High-quality output expected")
â”‚   â”‚           
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚           
â”‚   â”‚           return {
â”‚   â”‚               'status': 'success',
â”‚   â”‚               'model': info
â”‚   â”‚           }
â”‚   â”‚       
â”‚   â”‚       def save_scan_results(self, output_file: str = "model_scan_results.json"):
â”‚   â”‚           """Save scan results to JSON file"""
â”‚   â”‚           loaded_model = self.get_loaded_model()
â”‚   â”‚           if not loaded_model:
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           info = self.get_model_info(loaded_model['id'])
â”‚   â”‚           
â”‚   â”‚           scan_data = {
â”‚   â”‚               'scan_timestamp': str(Path.cwd()),
â”‚   â”‚               'lm_studio_url': self.base_url,
â”‚   â”‚               'model': info
â”‚   â”‚           }
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               with open(output_file, 'w') as f:
â”‚   â”‚                   json.dump(scan_data, f, indent=2)
â”‚   â”‚               print(f"{Fore.GREEN}âœ“ Scan results saved to: {output_file}")
â”‚   â”‚               return True
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print(f"{Fore.RED}âœ— Failed to save: {e}")
â”‚   â”‚               return False
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def main():
â”‚   â”‚       """Standalone scanner execution"""
â”‚   â”‚       scanner = EnhancedModelScanner()
â”‚   â”‚       result = scanner.scan_and_report()
â”‚   â”‚       
â”‚   â”‚       if result['status'] == 'success':
â”‚   â”‚           # Ask if user wants to save
â”‚   â”‚           save = input(f"\n{Fore.CYAN}Save scan results? (y/n): ").strip().lower()
â”‚   â”‚           if save == 'y':
â”‚   â”‚               scanner.save_scan_results()
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       main()
â”‚   â”‚   
â”‚   â”œâ”€â”€ human_evaluation.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   [Content omitted: Exceeds 20000 character limit]
â”‚   â”‚   
â”‚   â”œâ”€â”€ IndividualSongRenderer.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   INDIVIDUAL SONG RENDERER
â”‚   â”‚   ========================
â”‚   â”‚   Utility for rendering single songs from drafts with fine control
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   import json
â”‚   â”‚   import sys
â”‚   â”‚   import time
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from datetime import datetime
â”‚   â”‚   from colorama import Fore, init
â”‚   â”‚   
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   try:
â”‚   â”‚       from orphio_config import conf
â”‚   â”‚       from orphio_engine import OrphioEngine
â”‚   â”‚   except ImportError:
â”‚   â”‚       print(f"{Fore.RED}Error: Cannot import required modules.")
â”‚   â”‚       print(f"{Fore.YELLOW}Make sure this script is in the AGANCY folder.")
â”‚   â”‚       sys.exit(1)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class IndividualSongRenderer:
â”‚   â”‚       """Handles rendering of individual songs from draft files"""
â”‚   â”‚       
â”‚   â”‚       def __init__(self):
â”‚   â”‚           self.engine = OrphioEngine(log_callback=self.log)
â”‚   â”‚           
â”‚   â”‚       def log(self, message, color="white"):
â”‚   â”‚           """Print colored log message"""
â”‚   â”‚           colors = {
â”‚   â”‚               "red": Fore.RED,
â”‚   â”‚               "green": Fore.GREEN,
â”‚   â”‚               "yellow": Fore.YELLOW,
â”‚   â”‚               "cyan": Fore.CYAN,
â”‚   â”‚               "magenta": Fore.MAGENTA,
â”‚   â”‚               "white": Fore.WHITE
â”‚   â”‚           }
â”‚   â”‚           color_code = colors.get(color, Fore.WHITE)
â”‚   â”‚           timestamp = datetime.now().strftime("%H:%M:%S")
â”‚   â”‚           print(f"{color_code}[{timestamp}] {message}")
â”‚   â”‚       
â”‚   â”‚       def find_albums(self):
â”‚   â”‚           """Find all album directories"""
â”‚   â”‚           return [d for d in conf.OUTPUT_DIR.iterdir() if d.is_dir() and "ALBUM_" in d.name]
â”‚   â”‚       
â”‚   â”‚       def find_drafts_in_album(self, album_dir):
â”‚   â”‚           """Find all draft files in an album"""
â”‚   â”‚           return sorted(list(Path(album_dir).glob("*_DRAFT.json")))
â”‚   â”‚       
â”‚   â”‚       def load_draft(self, draft_file):
â”‚   â”‚           """Load draft data from file"""
â”‚   â”‚           try:
â”‚   â”‚               with open(draft_file, 'r', encoding='utf-8') as f:
â”‚   â”‚                   return json.load(f)
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.log(f"Error loading draft: {e}", "red")
â”‚   â”‚               return None
â”‚   â”‚       
â”‚   â”‚       def render_song(self, draft_file, duration=120, cfg_scale=1.5):
â”‚   â”‚           """Render a single song from draft"""
â”‚   â”‚           self.log(f"Loading draft: {draft_file.name}", "cyan")
â”‚   â”‚           
â”‚   â”‚           draft_data = self.load_draft(draft_file)
â”‚   â”‚           if not draft_data:
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           # Extract parameters
â”‚   â”‚           params = draft_data.get("parameters", {})
â”‚   â”‚           title = draft_data.get("title", "Untitled")
â”‚   â”‚           lyrics = params.get("lyrics", "")
â”‚   â”‚           tags = params.get("tags", [])
â”‚   â”‚           
â”‚   â”‚           if not lyrics:
â”‚   â”‚               self.log("No lyrics found in draft!", "red")
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           self.log(f"Title: {title}", "white")
â”‚   â”‚           self.log(f"Tags: {', '.join(tags)}", "yellow")
â”‚   â”‚           self.log(f"Duration: {duration}s, CFG: {cfg_scale}", "yellow")
â”‚   â”‚           
â”‚   â”‚           # Render
â”‚   â”‚           try:
â”‚   â”‚               self.log("Starting audio generation...", "magenta")
â”‚   â”‚               self.engine.free_memory()
â”‚   â”‚               
â”‚   â”‚               wav_path, ledger = self.engine.render_audio_stage(
â”‚   â”‚                   topic=title,
â”‚   â”‚                   lyrics=lyrics,
â”‚   â”‚                   tags=tags,
â”‚   â”‚                   duration_s=duration,
â”‚   â”‚                   cfg=cfg_scale,
â”‚   â”‚                   temp=1.0
â”‚   â”‚               )
â”‚   â”‚               
â”‚   â”‚               # Move rendered file to album directory
â”‚   â”‚               album_dir = draft_file.parent
â”‚   â”‚               safe_title = "".join([c for c in title if c.isalnum() or c in " _-"]).replace(" ", "_")
â”‚   â”‚               track_num = draft_data.get("track_number", 1)
â”‚   â”‚               
â”‚   â”‚               final_wav = album_dir / f"{track_num:02d}_{safe_title}.wav"
â”‚   â”‚               final_json = album_dir / f"{track_num:02d}_{safe_title}.json"
â”‚   â”‚               
â”‚   â”‚               # Move files
â”‚   â”‚               if Path(wav_path).exists():
â”‚   â”‚                   Path(wav_path).rename(final_wav)
â”‚   â”‚                   self.log(f"âœ“ Audio saved: {final_wav.name}", "green")
â”‚   â”‚               
â”‚   â”‚               json_path = Path(wav_path).with_suffix('.json')
â”‚   â”‚               if json_path.exists():
â”‚   â”‚                   json_path.rename(final_json)
â”‚   â”‚                   self.log(f"âœ“ Ledger saved: {final_json.name}", "green")
â”‚   â”‚               
â”‚   â”‚               # Delete draft file
â”‚   â”‚               draft_file.unlink()
â”‚   â”‚               self.log(f"âœ“ Removed draft: {draft_file.name}", "yellow")
â”‚   â”‚               
â”‚   â”‚               return True
â”‚   â”‚               
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.log(f"âœ— Render failed: {str(e)}", "red")
â”‚   â”‚               import traceback
â”‚   â”‚               traceback.print_exc()
â”‚   â”‚               return False
â”‚   â”‚       
â”‚   â”‚       def interactive_select_and_render(self):
â”‚   â”‚           """Interactive mode to select and render a song"""
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}")
â”‚   â”‚           print(f"{Fore.CYAN}  INDIVIDUAL SONG RENDERER")
â”‚   â”‚           print(f"{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚           
â”‚   â”‚           # Find albums
â”‚   â”‚           albums = self.find_albums()
â”‚   â”‚           
â”‚   â”‚           if not albums:
â”‚   â”‚               self.log("No albums found!", "red")
â”‚   â”‚               return
â”‚   â”‚           
â”‚   â”‚           # Select album
â”‚   â”‚           print(f"{Fore.WHITE}Available Albums:")
â”‚   â”‚           for i, album in enumerate(albums, 1):
â”‚   â”‚               draft_count = len(list(album.glob("*_DRAFT.json")))
â”‚   â”‚               print(f"  {Fore.YELLOW}[{i}]{Fore.WHITE} {album.name} {Fore.CYAN}({draft_count} drafts)")
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               album_choice = int(input(f"\n{Fore.GREEN}Select album number: ")) - 1
â”‚   â”‚               if album_choice < 0 or album_choice >= len(albums):
â”‚   â”‚                   raise ValueError
â”‚   â”‚           except (ValueError, KeyboardInterrupt):
â”‚   â”‚               self.log("Invalid selection or cancelled", "red")
â”‚   â”‚               return
â”‚   â”‚           
â”‚   â”‚           selected_album = albums[album_choice]
â”‚   â”‚           drafts = self.find_drafts_in_album(selected_album)
â”‚   â”‚           
â”‚   â”‚           if not drafts:
â”‚   â”‚               self.log("No drafts found in this album!", "red")
â”‚   â”‚               return
â”‚   â”‚           
â”‚   â”‚           # Select draft
â”‚   â”‚           print(f"\n{Fore.WHITE}Available Drafts:")
â”‚   â”‚           for i, draft in enumerate(drafts, 1):
â”‚   â”‚               draft_data = self.load_draft(draft)
â”‚   â”‚               if draft_data:
â”‚   â”‚                   title = draft_data.get("title", "Unknown")
â”‚   â”‚                   status = draft_data.get("status", "DRAFT")
â”‚   â”‚                   print(f"  {Fore.YELLOW}[{i}]{Fore.WHITE} {title} {Fore.CYAN}[{status}]")
â”‚   â”‚           
â”‚   â”‚           print(f"  {Fore.YELLOW}[0]{Fore.WHITE} Render ALL drafts")
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               draft_choice = int(input(f"\n{Fore.GREEN}Select draft number (0 for all): "))
â”‚   â”‚               if draft_choice < 0 or draft_choice > len(drafts):
â”‚   â”‚                   raise ValueError
â”‚   â”‚           except (ValueError, KeyboardInterrupt):
â”‚   â”‚               self.log("Invalid selection or cancelled", "red")
â”‚   â”‚               return
â”‚   â”‚           
â”‚   â”‚           # Get render settings
â”‚   â”‚           print(f"\n{Fore.WHITE}Render Settings:")
â”‚   â”‚           try:
â”‚   â”‚               duration = int(input(f"{Fore.CYAN}Duration (seconds) [120]: ") or "120")
â”‚   â”‚               cfg_input = input(f"{Fore.CYAN}CFG Scale (1.0-3.0) [1.5]: ") or "1.5"
â”‚   â”‚               cfg_scale = float(cfg_input)
â”‚   â”‚           except ValueError:
â”‚   â”‚               self.log("Invalid settings, using defaults", "yellow")
â”‚   â”‚               duration = 120
â”‚   â”‚               cfg_scale = 1.5
â”‚   â”‚           
â”‚   â”‚           # Render
â”‚   â”‚           if draft_choice == 0:
â”‚   â”‚               # Render all
â”‚   â”‚               self.log(f"\nRendering ALL {len(drafts)} songs...", "cyan")
â”‚   â”‚               success_count = 0
â”‚   â”‚               
â”‚   â”‚               for i, draft in enumerate(drafts, 1):
â”‚   â”‚                   self.log(f"\n--- Song {i}/{len(drafts)} ---", "white")
â”‚   â”‚                   if self.render_song(draft, duration, cfg_scale):
â”‚   â”‚                       success_count += 1
â”‚   â”‚                   time.sleep(2)  # Brief pause between renders
â”‚   â”‚               
â”‚   â”‚               self.log(f"\nâœ“ Completed: {success_count}/{len(drafts)} songs rendered", "green")
â”‚   â”‚           else:
â”‚   â”‚               # Render single
â”‚   â”‚               selected_draft = drafts[draft_choice - 1]
â”‚   â”‚               self.render_song(selected_draft, duration, cfg_scale)
â”‚   â”‚           
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def main():
â”‚   â”‚       """Main entry point"""
â”‚   â”‚       renderer = IndividualSongRenderer()
â”‚   â”‚       renderer.interactive_select_and_render()
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       main()
â”‚   â”‚   
â”‚   â”œâ”€â”€ lmstudio_controler.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   # AGANCY/lmstudio_controler.py
â”‚   â”‚   import requests
â”‚   â”‚   import json
â”‚   â”‚   import re
â”‚   â”‚   from colorama import Fore, Style
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class LMStudioController:
â”‚   â”‚       def __init__(self, base_url):
â”‚   â”‚           self.base_url = base_url.rstrip('/')
â”‚   â”‚   
â”‚   â”‚       def get_active_model(self):
â”‚   â”‚           """Fetches the exact ID of the currently loaded model from LM Studio."""
â”‚   â”‚           try:
â”‚   â”‚               res = requests.get(f"{self.base_url}/models", timeout=2)
â”‚   â”‚               if res.status_code == 200:
â”‚   â”‚                   data = res.json()
â”‚   â”‚                   if data.get('data') and len(data['data']) > 0:
â”‚   â”‚                       return data['data'][0]['id']
â”‚   â”‚           except:
â”‚   â”‚               pass
â”‚   â”‚           return "local-model"
â”‚   â”‚   
â”‚   â”‚       def check_connection(self):
â”‚   â”‚           """Returns (bool, message) regarding connection status."""
â”‚   â”‚           try:
â”‚   â”‚               model_id = self.get_active_model()
â”‚   â”‚               res = requests.get(f"{self.base_url}/models", timeout=3)
â”‚   â”‚               if res.status_code == 200:
â”‚   â”‚                   return True, f"Connected: {model_id}"
â”‚   â”‚               return False, f"HTTP Error {res.status_code}"
â”‚   â”‚           except requests.exceptions.ConnectionError:
â”‚   â”‚               return False, "Connection Refused (Is LM Studio Server ON?)"
â”‚   â”‚           except Exception as e:
â”‚   â”‚               return False, str(e)
â”‚   â”‚   
â”‚   â”‚       def detect_and_clean_reasoning(self, content):
â”‚   â”‚           """
â”‚   â”‚           SMART DETECTOR: Removes DeepSeek/R1 <think> blocks and handles
â”‚   â”‚           <|begin_of_box|> artifacts to ensure only the final lyrics remain.
â”‚   â”‚           """
â”‚   â”‚           original_len = len(content)
â”‚   â”‚   
â”‚   â”‚           # 1. Remove DeepSeek / Chain-of-Thought <think> blocks
â”‚   â”‚           # re.DOTALL is crucial here to match newlines inside the thought block
â”‚   â”‚           content = re.sub(r'<think>.*?</think>', '', content, flags=re.DOTALL | re.IGNORECASE)
â”‚   â”‚           content = re.sub(r'<thought>.*?</thought>', '', content, flags=re.DOTALL | re.IGNORECASE)
â”‚   â”‚   
â”‚   â”‚           # 2. Handle "Boxed" output (Common in R1 distillations)
â”‚   â”‚           # If the model wraps the final answer in box tags, we ONLY want what's inside.
â”‚   â”‚           if "<|begin_of_box|>" in content:
â”‚   â”‚               # Split and take everything AFTER the begin tag
â”‚   â”‚               content = content.split("<|begin_of_box|>")[-1]
â”‚   â”‚   
â”‚   â”‚           if "<|end_of_box|>" in content:
â”‚   â”‚               # Split and take everything BEFORE the end tag
â”‚   â”‚               content = content.split("<|end_of_box|>")[0]
â”‚   â”‚   
â”‚   â”‚           # 3. Clean up Markdown code blocks if the model wrapped lyrics in ```
â”‚   â”‚           content = content.replace("```json", "").replace("```lyrics", "").replace("```", "")
â”‚   â”‚   
â”‚   â”‚           content = content.strip()
â”‚   â”‚   
â”‚   â”‚           if len(content) < original_len:
â”‚   â”‚               print(f"{Fore.YELLOW}   ğŸ§¹ Scrubbed {original_len - len(content)} chars of 'Thinking'/'System' tokens.")
â”‚   â”‚   
â”‚   â”‚           return content
â”‚   â”‚   
â”‚   â”‚       def chat(self, system_prompt, user_content, temp=0.7):
â”‚   â”‚           """
â”‚   â”‚           Sends a chat request. Includes reasoning detection and
â”‚   â”‚           extended timeouts for slow models.
â”‚   â”‚           """
â”‚   â”‚           model_id = self.get_active_model()
â”‚   â”‚   
â”‚   â”‚           payload = {
â”‚   â”‚               "model": model_id,
â”‚   â”‚               "messages": [
â”‚   â”‚                   {"role": "system", "content": system_prompt},
â”‚   â”‚                   {"role": "user", "content": user_content}
â”‚   â”‚               ],
â”‚   â”‚               "temperature": temp,
â”‚   â”‚               "stream": False,
â”‚   â”‚               "max_tokens": -1
â”‚   â”‚           }
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               # We set a long timeout (600s) because Reasoning models 'think'
â”‚   â”‚               # for a long time before sending the first character.
â”‚   â”‚               res = requests.post(
â”‚   â”‚                   f"{self.base_url}/chat/completions",
â”‚   â”‚                   json=payload,
â”‚   â”‚                   timeout=600
â”‚   â”‚               )
â”‚   â”‚   
â”‚   â”‚               # Retry with generic ID if specific ID fails
â”‚   â”‚               if res.status_code == 400:
â”‚   â”‚                   print(f"{Fore.YELLOW}âš ï¸  Retrying with generic 'local-model' ID...")
â”‚   â”‚                   payload["model"] = "local-model"
â”‚   â”‚                   res = requests.post(f"{self.base_url}/chat/completions", json=payload, timeout=600)
â”‚   â”‚   
â”‚   â”‚               if res.status_code != 200:
â”‚   â”‚                   raise Exception(f"LM Studio Error {res.status_code}: {res.text}")
â”‚   â”‚   
â”‚   â”‚               data = res.json()
â”‚   â”‚               raw_response = data['choices'][0]['message']['content'].strip()
â”‚   â”‚               print(raw_response)
â”‚   â”‚               # Pass through the Smart Detector
â”‚   â”‚               processed_response = self.detect_and_clean_reasoning(raw_response)
â”‚   â”‚   
â”‚   â”‚               return processed_response
â”‚   â”‚   
â”‚   â”‚           except requests.exceptions.Timeout:
â”‚   â”‚               print(f"{Fore.RED}âŒ ERROR: LLM timed out after 10 minutes.")
â”‚   â”‚               raise TimeoutError("The model took too long to think. Try a smaller model (Llama-3 8B).")
â”‚   â”‚           except requests.exceptions.ConnectionError:
â”‚   â”‚               raise ConnectionError("Lost connection to LM Studio. Ensure the server is RUNNING.")
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print(f"{Fore.RED}LLM Chat Error: {e}")
â”‚   â”‚               raise e
â”‚   â”‚   
â”‚   â”‚       def unload_model(self):
â”‚   â”‚           """
â”‚   â”‚           Attempts to unload the model to free VRAM for the Audio Engine.
â”‚   â”‚           (Requires LM Studio SDK to be installed in the environment)
â”‚   â”‚           """
â”‚   â”‚           try:
â”‚   â”‚               import lmstudio as lms
â”‚   â”‚               lms.llm().unload()
â”‚   â”‚               return True
â”‚   â”‚           except:
â”‚   â”‚               # Fallback: Many setups don't have the SDK, so we just return False
â”‚   â”‚               # and let the engine handle VRAM clearing via torch.cuda.empty_cache()
â”‚   â”‚               return False
â”‚   â”‚   
â”‚   â”œâ”€â”€ Orphio_Command_Center2.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   [Content omitted: Exceeds 20000 character limit]
â”‚   â”‚   
â”‚   â”œâ”€â”€ orphio_config.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚   
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try:
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except:
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   # AGANCY/orphio_config.py
â”‚   â”‚   import os
â”‚   â”‚   import json
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from dataclasses import dataclass
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def find_actual_root():
â”‚   â”‚       """Finds the folder containing the 'ckpt' directory."""
â”‚   â”‚       current = Path(__file__).resolve()
â”‚   â”‚       for parent in [current] + list(current.parents):
â”‚   â”‚           if (parent / "ckpt").exists():
â”‚   â”‚               return parent
â”‚   â”‚       return Path(__file__).resolve().parent.parent
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   @dataclass
â”‚   â”‚   class Config:
â”‚   â”‚       # Path Configuration
â”‚   â”‚       ROOT_DIR: Path = find_actual_root()
â”‚   â”‚       CKPT_DIR: Path = ROOT_DIR / "ckpt"
â”‚   â”‚       SRC_DIR: Path = ROOT_DIR / "src"
â”‚   â”‚       OUTPUT_DIR: Path = ROOT_DIR / "GROUND_TRUTH_ComboAi" / "outputSongs_ComboAi"
â”‚   â”‚       TAGS_FILE: Path = ROOT_DIR / "GROUND_TRUTH_ComboAi" / "tags.json"
â”‚   â”‚   
â”‚   â”‚       # Network Configuration
â”‚   â”‚       LM_STUDIO_URL: str = "http://localhost:1234/v1"
â”‚   â”‚   
â”‚   â”‚       # Audio Engine Settings
â”‚   â”‚       COOLFOOT_WAIT: float = 0.1
â”‚   â”‚       SAMPLE_RATE: int = 48000
â”‚   â”‚       FADE_OUT_DURATION: float = 0.2
â”‚   â”‚   
â”‚   â”‚       # =========================================================================
â”‚   â”‚       # RENDERING PARAMETER RANGES (NEW)
â”‚   â”‚       # =========================================================================
â”‚   â”‚       # These define the allowed ranges for user adjustment
â”‚   â”‚       CFG_RANGE: tuple = (1.0, 3.0)  # Classifier-Free Guidance Scale range
â”‚   â”‚       TEMP_RANGE: tuple = (0.7, 1.3)  # Temperature range for generation
â”‚   â”‚       DURATION_RANGE: tuple = (30, 300)  # Duration in seconds (min, max)
â”‚   â”‚   
â”‚   â”‚       # Default values (used as initial settings)
â”‚   â”‚       DEFAULT_CFG: float = 1.5  # Default CFG scale
â”‚   â”‚       DEFAULT_TEMP: float = 1.0  # Default temperature
â”‚   â”‚       DEFAULT_DURATION: int = 120  # Default duration in seconds
â”‚   â”‚   
â”‚   â”‚       # =========================================================================
â”‚   â”‚       # DECORATOR SCHEMA SELECTION
â”‚   â”‚       # =========================================================================
â”‚   â”‚       CURRENT_DECORATOR_SCHEMA: str = "1_clean_standard"
â”‚   â”‚   
â”‚   â”‚       # =========================================================================
â”‚   â”‚       # LLM PROMPTS
â”‚   â”‚       # =========================================================================
â”‚   â”‚       PROMPT_WRITER: str = (
â”‚   â”‚           "You are a professional Songwriter. Write clean lyrics based on the user's topic.\n"
â”‚   â”‚           "STRICT FORMATTING:\n"
â”‚   â”‚           "1. Use UPPERCASE tags in brackets: [INTRO], [VERSE 1], [CHORUS], [BRIDGE], [OUTRO].\n"
â”‚   â”‚           "2. Do NOT use markdown bolding (**).\n"
â”‚   â”‚           "3. Write ONLY the lyrics and structure tags.\n"
â”‚   â”‚           "4. Do not add any decorations yet."
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚       PROMPT_TAGGER: str = (
â”‚   â”‚           "You are a Metadata Specialist. Analyze the lyrics and select tags.\n"
â”‚   â”‚           "STRICT RULES:\n"
â”‚   â”‚           "1. Select ONE tag for 'GENRE' (Mandatory).\n"
â”‚   â”‚           "2. Select tags for Timbre, Gender, Mood.\n"
â”‚   â”‚           "3. Output a simple comma-separated list of words only.\n"
â”‚   â”‚           "4. Example: Electronic, Dark, Female, Energetic, Synthesizer"
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚       # =========================================================================
â”‚   â”‚       # DECORATION STRATEGIES (The "Secret Sauce" for Audio Gen)
â”‚   â”‚       # =========================================================================
â”‚   â”‚       DECORATOR_SCHEMAS = {
â”‚   â”‚           "1_clean_standard": (
â”‚   â”‚               "You are a Lyric Formatter. Output the lyrics exactly as they are.\n"
â”‚   â”‚               "Ensure structure tags like [INTRO] and [CHORUS] are present.\n"
â”‚   â”‚               "Do NOT add any symbols, visual effects, or parenthesis.\n"
â”‚   â”‚               "Keep it clean."
â”‚   â”‚           ),
â”‚   â”‚   
â”‚   â”‚           "2_sonic_flow_extended": (
â”‚   â”‚               "You are a Vocal Arranger. Add symbols to control rhythm and duration.\n"
â”‚   â”‚               "RULES:\n"
â”‚   â”‚               "1. Add `...` (ellipses) where the singer should pause for breath.\n"
â”‚   â”‚               "2. Add `~~~` (tildes) to the end of vowels to hold/elongate the note.\n"
â”‚   â”‚               "3. Add `__` (underscores) between words that should be sung quickly together.\n"
â”‚   â”‚               "4. Keep the [TAGS] intact.\n"
â”‚   â”‚               "EXAMPLE:\n"
â”‚   â”‚               "The night is yoooooung~~~\n"
â”‚   â”‚               "But we are... running__out__of__time..."
â”‚   â”‚           ),
â”‚   â”‚   
â”‚   â”‚           "3_dynamic_performer": (
â”‚   â”‚               "You are a Drama Director. Add parenthetical performance instructions.\n"
â”‚   â”‚               "RULES:\n"
â”‚   â”‚               "1. Add (whisper), (shout), (gasp), (belting), or (spoken) before specific lines.\n"
â”‚   â”‚               "2. Use `!` liberally for emphasis.\n"
â”‚   â”‚               "3. Do not change the words, just add the mood instructions.\n"
â”‚   â”‚               "EXAMPLE:\n"
â”‚   â”‚               "[VERSE 1]\n"
â”‚   â”‚               "(whisper) I hear them coming...\n"
â”‚   â”‚               "(shout) BUT I WON'T RUN!"
â”‚   â”‚           ),
â”‚   â”‚   
â”‚   â”‚           "4_glitch_stutter": (
â”‚   â”‚               "You are an Electronic Music Producer. Apply 'glitch' effects to the text.\n"
â”‚   â”‚               "RULES:\n"
â”‚   â”‚               "1. Stutter the first letter of intense words (e.g., 'b-b-break').\n"
â”‚   â”‚               "2. Repeat key phrases twice rapidly.\n"
â”‚   â”‚               "3. Insert `[//]` or `[::]` to signify digital breaks/artifacts.\n"
â”‚   â”‚               "EXAMPLE:\n"
â”‚   â”‚               "Sys-sys-system fa-failure...\n"
â”‚   â”‚               "I can't [//] I can't breathe.\n"
â”‚   â”‚               "R-r-reset the code [::]"
â”‚   â”‚           ),
â”‚   â”‚   
â”‚   â”‚           "5_call_and_response": (
â”‚   â”‚               "You are a Choir Arranger. Add background vocals and ad-libs.\n"
â”‚   â”‚               "RULES:\n"
â”‚   â”‚               "1. Add background vocals in parenthesis at the end of lines.\n"
â”‚   â”‚               "2. Examples: (Ooh yeah), (No no no), (Echoing).\n"
â”‚   â”‚               "3. Ensure the main lyrics remain visible.\n"
â”‚   â”‚               "EXAMPLE:\n"
â”‚   â”‚               "Walking down the street (All alone)\n"
â”‚   â”‚               "Looking at my feet (Yeah yeah)\n"
â”‚   â”‚               "Nobody knows my name (Nobody knows)"
â”‚   â”‚           ),
â”‚   â”‚   
â”‚   â”‚           "6_abstract_symbolism": (
â”‚   â”‚               "You are an Experimental Composer. Use non-standard symbols to trigger AI attention.\n"
â”‚   â”‚               "RULES:\n"
â”‚   â”‚               "1. Surround the Chorus with `***`.\n"
â”‚   â”‚               "2. Use `|` to mark strict bars or beats.\n"
â”‚   â”‚               "3. Use `^` for rising pitch and `v` for falling pitch.\n"
â”‚   â”‚               "EXAMPLE:\n"
â”‚   â”‚               "| Rising up ^ | Falling down v |\n"
â”‚   â”‚               "***\n"
â”‚   â”‚               "[CHORUS]\n"
â”‚   â”‚               "This is the core ^^^^ \n"
â”‚   â”‚               "***"
â”‚   â”‚           )
â”‚   â”‚       }
â”‚   â”‚   
â”‚   â”‚       def validate(self):
â”‚   â”‚           """Validates and creates necessary directories and files"""
â”‚   â”‚           self.OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
â”‚   â”‚   
â”‚   â”‚           # Ensure tags file exists
â”‚   â”‚           if not self.TAGS_FILE.exists():
â”‚   â”‚               default_tags = {
â”‚   â”‚                   "Genre": ["Pop", "Rock", "Electronic", "Jazz"],
â”‚   â”‚                   "Mood": ["Happy", "Sad", "Energetic"],
â”‚   â”‚                   "Gender": ["Male", "Female"]
â”‚   â”‚               }
â”‚   â”‚               with open(self.TAGS_FILE, 'w') as f:
â”‚   â”‚                   json.dump(default_tags, f, indent=4)
â”‚   â”‚   
â”‚   â”‚       def set_output_dir(self, new_path: str):
â”‚   â”‚           """Updates the output directory"""
â”‚   â”‚           path = Path(new_path)
â”‚   â”‚           if path.exists() and path.is_dir():
â”‚   â”‚               self.OUTPUT_DIR = path
â”‚   â”‚               print(f"âœ… Vault Directory changed to: {self.OUTPUT_DIR}")
â”‚   â”‚           else:
â”‚   â”‚               print("âŒ Invalid directory selected.")
â”‚   â”‚   
â”‚   â”‚       def update_defaults(self, cfg=None, temp=None, duration=None):
â”‚   â”‚           """Updates default rendering parameters"""
â”‚   â”‚           if cfg is not None and self.CFG_RANGE[0] <= cfg <= self.CFG_RANGE[1]:
â”‚   â”‚               self.DEFAULT_CFG = cfg
â”‚   â”‚           if temp is not None and self.TEMP_RANGE[0] <= temp <= self.TEMP_RANGE[1]:
â”‚   â”‚               self.DEFAULT_TEMP = temp
â”‚   â”‚           if duration is not None and self.DURATION_RANGE[0] <= duration <= self.DURATION_RANGE[1]:
â”‚   â”‚               self.DEFAULT_DURATION = duration
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Initialize global config instance
â”‚   â”‚   conf = Config()
â”‚   â”‚   conf.validate()
â”‚   â”‚   
â”‚   â”œâ”€â”€ orphio_engine.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   # AGANCY/orphio_engine.py
â”‚   â”‚   import sys
â”‚   â”‚   import time
â”‚   â”‚   import torch
â”‚   â”‚   import gc
â”‚   â”‚   import re
â”‚   â”‚   import os
â”‚   â”‚   import random
â”‚   â”‚   import numpy as np
â”‚   â”‚   import scipy.io.wavfile
â”‚   â”‚   import torchaudio
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   
â”‚   â”‚   from orphio_config import conf
â”‚   â”‚   from lmstudio_controler import LMStudioController
â”‚   â”‚   from orphio_schema import MasterLedger
â”‚   â”‚   
â”‚   â”‚   # ==============================================================================
â”‚   â”‚   # ğŸ©¹ RUNTIME PATCH: Fix PyTorch 2.4.1 + Python 3.12 Type Hint Error
â”‚   â”‚   # ==============================================================================
â”‚   â”‚   try:
â”‚   â”‚       from torch._inductor.codegen import common
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚       class PatchedCSE(dict):
â”‚   â”‚           @classmethod
â”‚   â”‚           def __class_getitem__(cls, item): return cls
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚       common.CSE = PatchedCSE
â”‚   â”‚   except ImportError:
â”‚   â”‚       pass
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class OrphioEngine:
â”‚   â”‚       def __init__(self, log_callback=print):
â”‚   â”‚           self.log = log_callback
â”‚   â”‚           self.lms = LMStudioController(conf.LM_STUDIO_URL)
â”‚   â”‚           self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
â”‚   â”‚           self.captured_audio = []
â”‚   â”‚   
â”‚   â”‚       def free_memory(self):
â”‚   â”‚           """Clears GPU cache and forces garbage collection."""
â”‚   â”‚           gc.collect()
â”‚   â”‚           if torch.cuda.is_available():
â”‚   â”‚               torch.cuda.empty_cache()
â”‚   â”‚               torch.cuda.synchronize()
â”‚   â”‚   
â”‚   â”‚       def _enforce_tag_schema(self, text):
â”‚   â”‚           """Removes LLM bolding (**[INTRO]**) and forces uppercase tags."""
â”‚   â”‚   
â”‚   â”‚           def replace_tag(match):
â”‚   â”‚               content = match.group(2).strip().upper()
â”‚   â”‚               return f"[{content}]"
â”‚   â”‚   
â”‚   â”‚           return re.sub(r'(\*\*|__)?\[\s*(.*?)\s*\](\*\*|__)?', replace_tag, text)
â”‚   â”‚   
â”‚   â”‚       def _clean_tags_list(self, raw_tags):
â”‚   â”‚           """
â”‚   â”‚           Smart Scrubber: Enforces 8-Pillar Priority.
â”‚   â”‚           """
â”‚   â”‚           text = raw_tags.replace('**', '').replace('__', '').replace('*', '')
â”‚   â”‚           parts = re.split(r'[\n,;\tâ€¢]', text)
â”‚   â”‚   
â”‚   â”‚           # Define the High-Priority Anchors manually
â”‚   â”‚           known_genres = ["pop", "rock", "electronic", "hiphop", "jazz", "classical", "techno", "trance", "ambient",
â”‚   â”‚                           "folk", "country"]
â”‚   â”‚   
â”‚   â”‚           found_anchors = []
â”‚   â”‚           other_tags = []
â”‚   â”‚   
â”‚   â”‚           for p in parts:
â”‚   â”‚               p = re.sub(r'^\d+[\.\)]\s*', '', p.strip())
â”‚   â”‚               if ':' in p: p = p.split(':')[0]
â”‚   â”‚               clean_tag = p.strip().lower()
â”‚   â”‚   
â”‚   â”‚               if not clean_tag or len(clean_tag) < 2: continue
â”‚   â”‚   
â”‚   â”‚               # Sort into Anchor vs Seasoning
â”‚   â”‚               if clean_tag in known_genres:
â”‚   â”‚                   found_anchors.append(clean_tag)
â”‚   â”‚               else:
â”‚   â”‚                   other_tags.append(clean_tag)
â”‚   â”‚   
â”‚   â”‚           # Remove duplicates while preserving order
â”‚   â”‚           found_anchors = list(dict.fromkeys(found_anchors))
â”‚   â”‚           other_tags = list(dict.fromkeys(other_tags))
â”‚   â”‚   
â”‚   â”‚           # REASSEMBLE: Anchors FIRST (Crucial for HeartMuLa stability)
â”‚   â”‚           # Limit to 1 Anchor (to avoid conflict) + 5 Seasoning tags
â”‚   â”‚           final_tags = found_anchors[:1] + other_tags
â”‚   â”‚   
â”‚   â”‚           # Ensure we don't exceed 6 tags total (Prompting Strategy: "Less is More")
â”‚   â”‚           return final_tags[:6] if final_tags else ["melodic", "electronic"]
â”‚   â”‚   
â”‚   â”‚       def generate_lyrics_stage(self, topic: str):
â”‚   â”‚           self.log("ğŸ”— Connecting to LM Studio...")
â”‚   â”‚           ok, msg = self.lms.check_connection()
â”‚   â”‚           if not ok: raise ConnectionError(msg)
â”‚   â”‚           lyrics = self.lms.chat(conf.PROMPT_WRITER, f"Topic: {topic}")
â”‚   â”‚           lyrics = self._enforce_tag_schema(lyrics)
â”‚   â”‚           tags_raw = self.lms.chat(conf.PROMPT_TAGGER, lyrics, temp=0.2)
â”‚   â”‚           tags_list = self._clean_tags_list(tags_raw)
â”‚   â”‚           return lyrics, tags_list
â”‚   â”‚   
â”‚   â”‚       def decorate_lyrics_stage(self, current_lyrics, tags_list):
â”‚   â”‚           schema_key = conf.CURRENT_DECORATOR_SCHEMA
â”‚   â”‚   
â”‚   â”‚           # --- FIXED LOGIC HERE ---
â”‚   â”‚           # 1. Try to get the specific requested schema
â”‚   â”‚           # 2. If not found, default to 'vocal_dynamics'
â”‚   â”‚           # 3. If that fails, just take the first one in the dictionary
â”‚   â”‚           decorator_prompt = conf.DECORATOR_SCHEMAS.get(
â”‚   â”‚               schema_key,
â”‚   â”‚               conf.DECORATOR_SCHEMAS.get("vocal_dynamics", next(iter(conf.DECORATOR_SCHEMAS.values())))
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚           user_prompt = f"Style: {', '.join(tags_list)}\n\nLyrics:\n{current_lyrics}"
â”‚   â”‚           decorated_text = self.lms.chat(decorator_prompt, user_prompt, temp=0.7)
â”‚   â”‚           return self._enforce_tag_schema(decorated_text) if decorated_text else current_lyrics
â”‚   â”‚   
â”‚   â”‚       def render_audio_stage(self, topic: str, lyrics: str, tags: list, duration_s: int, cfg: float, temp: float):
â”‚   â”‚           start_time = time.time()
â”‚   â”‚           self.log(f"ğŸ”Š Offloading LLM... Duration: {duration_s}s, CFG: {cfg}")
â”‚   â”‚           self.lms.unload_model()
â”‚   â”‚           self.free_memory()
â”‚   â”‚           time.sleep(conf.COOLFOOT_WAIT)
â”‚   â”‚   
â”‚   â”‚           if str(conf.SRC_DIR) not in sys.path:
â”‚   â”‚               sys.path.append(str(conf.SRC_DIR))
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               import heartlib.pipelines.music_generation as mg
â”‚   â”‚               from heartlib import HeartMuLaGenPipeline
â”‚   â”‚   
â”‚   â”‚               def patched_resolve_paths(pretrained_path, version):
â”‚   â”‚                   return (
â”‚   â”‚                       str(conf.CKPT_DIR / "HeartMuLa-oss-3B"),
â”‚   â”‚                       str(conf.CKPT_DIR / "HeartCodec-oss"),
â”‚   â”‚                       str(conf.CKPT_DIR / "tokenizer.json"),
â”‚   â”‚                       str(conf.CKPT_DIR / "gen_config.json")
â”‚   â”‚                   )
â”‚   â”‚   
â”‚   â”‚               mg._resolve_paths = patched_resolve_paths
â”‚   â”‚   
â”‚   â”‚               def _interceptor(uri, src, sr, **kwargs):
â”‚   â”‚                   self.captured_audio.append(src.detach().cpu())
â”‚   â”‚   
â”‚   â”‚               original_save = torchaudio.save
â”‚   â”‚               torchaudio.save = _interceptor
â”‚   â”‚               self.captured_audio = []
â”‚   â”‚   
â”‚   â”‚               pipeline = HeartMuLaGenPipeline.from_pretrained(
â”‚   â”‚                   pretrained_path=str(conf.CKPT_DIR),
â”‚   â”‚                   device=self.device,
â”‚   â”‚                   dtype={"mula": torch.bfloat16, "codec": torch.float32},
â”‚   â”‚                   version="IGNORE",
â”‚   â”‚                   lazy_load=True
â”‚   â”‚               )
â”‚   â”‚   
â”‚   â”‚               seed = random.randint(0, 2 ** 32 - 1)
â”‚   â”‚               torch.manual_seed(seed)
â”‚   â”‚               self.log(f"ğŸš€ Rendering Audio (Seed: {seed})...")
â”‚   â”‚   
â”‚   â”‚               with torch.inference_mode():
â”‚   â”‚                   pipeline(
â”‚   â”‚                       inputs={"lyrics": lyrics, "tags": ", ".join(tags)},
â”‚   â”‚                       max_audio_length_ms=duration_s * 1000,
â”‚   â”‚                       cfg_scale=cfg,
â”‚   â”‚                       temperature=temp
â”‚   â”‚                   )
â”‚   â”‚   
â”‚   â”‚               torchaudio.save = original_save
â”‚   â”‚               del pipeline
â”‚   â”‚               self.free_memory()
â”‚   â”‚   
â”‚   â”‚               if not self.captured_audio:
â”‚   â”‚                   raise RuntimeError("Audio pipeline finished but no audio was captured.")
â”‚   â”‚   
â”‚   â”‚               # --- FIXED BROADCASTING LOGIC ---
â”‚   â”‚               audio_np = self.captured_audio[0].numpy().squeeze()
â”‚   â”‚   
â”‚   â”‚               # Ensure shape is (Samples, Channels) for consistent processing
â”‚   â”‚               if audio_np.ndim == 2 and audio_np.shape[0] < audio_np.shape[1]:
â”‚   â”‚                   audio_np = audio_np.T
â”‚   â”‚   
â”‚   â”‚               # Normalize
â”‚   â”‚               if np.abs(audio_np).max() > 0:
â”‚   â”‚                   audio_np = audio_np / np.abs(audio_np).max() * 0.9
â”‚   â”‚   
â”‚   â”‚               # Apply Fade Out (Safe for Stereo/Mono)
â”‚   â”‚               fade_len = int(conf.FADE_OUT_DURATION * conf.SAMPLE_RATE)
â”‚   â”‚               if fade_len < len(audio_np):
â”‚   â”‚                   fade_ramp = np.linspace(1.0, 0.0, fade_len)
â”‚   â”‚                   # If audio is stereo (N, 2), expand ramp to (N, 1) so it broadcasts
â”‚   â”‚                   if audio_np.ndim == 2:
â”‚   â”‚                       fade_ramp = fade_ramp[:, np.newaxis]
â”‚   â”‚                   audio_np[-fade_len:] *= fade_ramp
â”‚   â”‚   
â”‚   â”‚               # Ledger
â”‚   â”‚               ledger = MasterLedger.create_new(topic, lyrics, tags, seed, duration_s, time.time() - start_time,
â”‚   â”‚                                                conf.ROOT_DIR)
â”‚   â”‚               wav_path = conf.OUTPUT_DIR / f"{ledger.provenance.id}.wav"
â”‚   â”‚   
â”‚   â”‚               # Save
â”‚   â”‚               scipy.io.wavfile.write(str(wav_path), conf.SAMPLE_RATE, (audio_np * 32767).astype(np.int16))
â”‚   â”‚               with open(wav_path.with_suffix('.json'), 'w') as f:
â”‚   â”‚                   f.write(ledger.model_dump_json(indent=4))
â”‚   â”‚   
â”‚   â”‚               return str(wav_path), ledger
â”‚   â”‚   
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.log(f"âŒ Error: {e}")
â”‚   â”‚               raise e
â”‚   â”‚   
â”‚   â”œâ”€â”€ orphio_schema.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   # AGANCY/orphio_schema.py
â”‚   â”‚   from pydantic import BaseModel, Field
â”‚   â”‚   from typing import List, Optional, Dict, Any
â”‚   â”‚   from datetime import datetime
â”‚   â”‚   import uuid
â”‚   â”‚   
â”‚   â”‚   # --- 1. SUB-MODELS ---
â”‚   â”‚   
â”‚   â”‚   class Provenance(BaseModel):
â”‚   â”‚       id: str
â”‚   â”‚       timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())
â”‚   â”‚       engine_uid: str = "HeartMuLa-Hybrid-OrphioAgency"
â”‚   â”‚       project_root: str
â”‚   â”‚   
â”‚   â”‚   class Configuration(BaseModel):
â”‚   â”‚       seed: int
â”‚   â”‚       cfg_scale: float = 1.5
â”‚   â”‚       temperature: float = 1.0
â”‚   â”‚       duration_sec: int
â”‚   â”‚       input_prompt: Dict[str, Any]
â”‚   â”‚   
â”‚   â”‚   class AutomatedMetrics(BaseModel):
â”‚   â”‚       generation_time_sec: float
â”‚   â”‚       audit_status: str = "PENDING"
â”‚   â”‚       lyric_accuracy_score: Optional[float] = None
â”‚   â”‚       raw_transcript: Optional[str] = None
â”‚   â”‚   
â”‚   â”‚   class HumanEvaluation(BaseModel):
â”‚   â”‚       # 1. JUDGMENT: Overall score (1-10)
â”‚   â”‚       overall_score: Optional[int] = None
â”‚   â”‚   
â”‚   â”‚       # 2. ADHERENCE: How well it matched the prompt tags
â”‚   â”‚       # Example: {"Rock": 9, "Sad": 2}
â”‚   â”‚       prompt_adherence_scores: Dict[str, int] = Field(default_factory=dict)
â”‚   â”‚   
â”‚   â”‚       # 3. FEEDBACK: What the human actually heard
â”‚   â”‚       # Example: ["Lo-Fi", "Guitar", "Sleepy"]
â”‚   â”‚       perceived_tags: List[str] = Field(default_factory=list)
â”‚   â”‚   
â”‚   â”‚       # 4. TECHNICAL AUDIT: Matrix scores
â”‚   â”‚       # Example: {"Mixing-Clarity": 1, "Clipping": -1}
â”‚   â”‚       technical_audit_scores: Dict[str, int] = Field(default_factory=dict)
â”‚   â”‚   
â”‚   â”‚       qualitative_notes: Optional[str] = None
â”‚   â”‚       status: str = "NOT_EVALUATED"
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # --- 2. MASTER MODEL ---
â”‚   â”‚   
â”‚   â”‚   class MasterLedger(BaseModel):
â”‚   â”‚       provenance: Provenance
â”‚   â”‚       configuration: Configuration
â”‚   â”‚       automated_metrics: AutomatedMetrics
â”‚   â”‚       human_evaluation: HumanEvaluation
â”‚   â”‚       status: str = "PRODUCED"
â”‚   â”‚   
â”‚   â”‚       @classmethod
â”‚   â”‚       def create_new(cls, topic, lyrics, tags, seed, duration, gen_time, root_path):
â”‚   â”‚           ts = datetime.now()
â”‚   â”‚           # Generate a unique ID for the song
â”‚   â”‚           safe_id = f"ORPHIO_{ts.strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}"
â”‚   â”‚   
â”‚   â”‚           return cls(
â”‚   â”‚               provenance=Provenance(id=safe_id, project_root=str(root_path)),
â”‚   â”‚               configuration=Configuration(
â”‚   â”‚                   seed=seed,
â”‚   â”‚                   duration_sec=duration,
â”‚   â”‚                   input_prompt={"topic": topic, "lyrics": lyrics, "tags": tags}
â”‚   â”‚               ),
â”‚   â”‚               automated_metrics=AutomatedMetrics(generation_time_sec=gen_time),
â”‚   â”‚               # This instantiates the HumanEvaluation class defined immediately above
â”‚   â”‚               human_evaluation=HumanEvaluation()
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”œâ”€â”€ OrphioMusicAgencyStudio_______start.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   import sys
â”‚   â”‚   import os
â”‚   â”‚   import json
â”‚   â”‚   import threading
â”‚   â”‚   import random
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   
â”‚   â”‚   # --- CRITICAL FIX FOR WINDOWS DLL ERRORS (WinError 1114) ---
â”‚   â”‚   # PyTorch MUST be imported BEFORE PyQt6 to initialize CUDA/C++ DLLs correctly.
â”‚   â”‚   os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚   
â”‚   â”‚   # --- FIX: SYSTEM PATHS ---
â”‚   â”‚   CURRENT_DIR = Path(__file__).resolve().parent
â”‚   â”‚   if str(CURRENT_DIR) not in sys.path:
â”‚   â”‚       sys.path.insert(0, str(CURRENT_DIR))
â”‚   â”‚   
â”‚   â”‚   # --- IMPORT ENGINE & CONFIG FIRST (Pre-loads Torch) ---
â”‚   â”‚   try:
â”‚   â”‚       from orphio_config import conf
â”‚   â”‚       from orphio_engine import OrphioEngine
â”‚   â”‚       # We verify torch loaded successfully
â”‚   â”‚       import torch
â”‚   â”‚       print(f"âœ… PyTorch loaded successfully. CUDA Available: {torch.cuda.is_available()}")
â”‚   â”‚   except ImportError as e:
â”‚   â”‚       print(f"âŒ Critical Engine Import Error: {e}")
â”‚   â”‚       sys.exit(1)
â”‚   â”‚   except OSError as e:
â”‚   â”‚       print(f"âŒ DLL Error (Visual C++ Redistributable might be missing): {e}")
â”‚   â”‚       sys.exit(1)
â”‚   â”‚   
â”‚   â”‚   # --- IMPORT PYQT6 AFTER TORCH ---
â”‚   â”‚   from PyQt6.QtWidgets import (
â”‚   â”‚       QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
â”‚   â”‚       QLabel, QPushButton, QTextEdit, QLineEdit, QFrame,
â”‚   â”‚       QProgressBar, QComboBox, QMessageBox, QSlider,
â”‚   â”‚       QScrollArea, QCheckBox, QGridLayout, QListWidget, QListWidgetItem,
â”‚   â”‚       QSplitter, QFileDialog, QPlainTextEdit, QSizePolicy
â”‚   â”‚   )
â”‚   â”‚   from PyQt6.QtCore import Qt, pyqtSignal, QObject, QUrl
â”‚   â”‚   from PyQt6.QtGui import QFont, QTextCursor, QPainter, QColor, QBrush
â”‚   â”‚   from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
â”‚   â”‚   
â”‚   â”‚   # --- INTERNAL IMPORTS ---
â”‚   â”‚   try:
â”‚   â”‚       from agency_styles import MODERN_STYLES
â”‚   â”‚       from tagSelector import TagSelectorDialog
â”‚   â”‚   except ImportError as e:
â”‚   â”‚       print(f"âŒ UI Component Import Error: {e}")
â”‚   â”‚       sys.exit(1)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # ============================================================
â”‚   â”‚   # 1. CUSTOM WIDGETS
â”‚   â”‚   # ============================================================
â”‚   â”‚   
â”‚   â”‚   class AgencyWaveform(QWidget):
â”‚   â”‚       seek_requested = pyqtSignal(int)
â”‚   â”‚   
â”‚   â”‚       def __init__(self):
â”‚   â”‚           super().__init__()
â”‚   â”‚           self.setFixedHeight(65)
â”‚   â”‚           self.setCursor(Qt.CursorShape.PointingHandCursor)
â”‚   â”‚           self.bars = []
â”‚   â”‚           self.progress = 0.0
â”‚   â”‚           self.duration_ms = 1
â”‚   â”‚           self.generate_random_shape(12345)
â”‚   â”‚   
â”‚   â”‚       def generate_random_shape(self, seed):
â”‚   â”‚           random.seed(seed)
â”‚   â”‚           self.bars = [random.uniform(0.15, 0.95) for _ in range(120)]
â”‚   â”‚           self.update()
â”‚   â”‚   
â”‚   â”‚       def set_progress(self, current_ms, total_ms):
â”‚   â”‚           if total_ms > 0:
â”‚   â”‚               self.progress = current_ms / total_ms
â”‚   â”‚               self.duration_ms = total_ms
â”‚   â”‚           else:
â”‚   â”‚               self.progress = 0
â”‚   â”‚           self.update()
â”‚   â”‚   
â”‚   â”‚       def paintEvent(self, event):
â”‚   â”‚           painter = QPainter(self)
â”‚   â”‚           painter.setRenderHint(QPainter.RenderHint.Antialiasing)
â”‚   â”‚           w, h = self.width(), self.height()
â”‚   â”‚           painter.fillRect(self.rect(), QColor("#050505"))
â”‚   â”‚           if not self.bars: return
â”‚   â”‚           bar_width = w / len(self.bars)
â”‚   â”‚           for i, h_factor in enumerate(self.bars):
â”‚   â”‚               bar_h = h * h_factor * 0.8
â”‚   â”‚               is_active = i <= int(self.progress * len(self.bars))
â”‚   â”‚               painter.setBrush(QBrush(QColor("#00FF7F") if is_active else QColor("#1F2937")))
â”‚   â”‚               painter.setPen(Qt.PenStyle.NoPen)
â”‚   â”‚               painter.drawRoundedRect(int(i * bar_width), int((h - bar_h) / 2), int(bar_width - 1), int(bar_h), 2, 2)
â”‚   â”‚   
â”‚   â”‚       def mousePressEvent(self, event):
â”‚   â”‚           if self.duration_ms <= 0: return
â”‚   â”‚           ratio = event.pos().x() / self.width()
â”‚   â”‚           self.seek_requested.emit(int(ratio * self.duration_ms))
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class WorkerSignals(QObject):
â”‚   â”‚       log = pyqtSignal(str)
â”‚   â”‚       finished_draft = pyqtSignal(str, list)
â”‚   â”‚       finished_decorate = pyqtSignal(str)
â”‚   â”‚       finished_render = pyqtSignal(str)
â”‚   â”‚       error = pyqtSignal(str)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # ============================================================
â”‚   â”‚   # 2. MAIN STUDIO ENGINE
â”‚   â”‚   # ============================================================
â”‚   â”‚   
â”‚   â”‚   class OrphioStudio(QMainWindow):
â”‚   â”‚       def __init__(self):
â”‚   â”‚           super().__init__()
â”‚   â”‚           self.setWindowTitle("ORPHIO AGENCY STUDIO v3.0")
â”‚   â”‚           self.resize(1750, 950)
â”‚   â”‚           self.setStyleSheet(MODERN_STYLES)
â”‚   â”‚   
â”‚   â”‚           self.signals = WorkerSignals()
â”‚   â”‚           self.signals.log.connect(self.log_system)
â”‚   â”‚           self.signals.finished_draft.connect(self.on_draft_complete)
â”‚   â”‚           self.signals.finished_decorate.connect(self.on_decorate_complete)
â”‚   â”‚           self.signals.finished_render.connect(self.on_render_complete)
â”‚   â”‚           self.signals.error.connect(self.on_error)
â”‚   â”‚   
â”‚   â”‚           self.engine = OrphioEngine(log_callback=lambda m: self.signals.log.emit(m))
â”‚   â”‚           self.player = QMediaPlayer()
â”‚   â”‚           self.audio_output = QAudioOutput()
â”‚   â”‚           self.player.setAudioOutput(self.audio_output)
â”‚   â”‚           self.player.positionChanged.connect(self.update_position)
â”‚   â”‚           self.player.durationChanged.connect(self.update_duration)
â”‚   â”‚           self.player.playbackStateChanged.connect(self.update_play_btn_icon)
â”‚   â”‚   
â”‚   â”‚           self.init_ui()
â”‚   â”‚           self.refresh_playlist()
â”‚   â”‚   
â”‚   â”‚       def init_ui(self):
â”‚   â”‚           central = QWidget()
â”‚   â”‚           self.setCentralWidget(central)
â”‚   â”‚           outer_layout = QVBoxLayout(central)
â”‚   â”‚           outer_layout.setContentsMargins(0, 0, 0, 0)
â”‚   â”‚   
â”‚   â”‚           main_h_layout = QHBoxLayout()
â”‚   â”‚   
â”‚   â”‚           # --- SIDEBAR (LEFT) ---
â”‚   â”‚           sidebar = QFrame(objectName="Sidebar")
â”‚   â”‚           sidebar.setFixedWidth(360)
â”‚   â”‚           side_lyt = QVBoxLayout(sidebar)
â”‚   â”‚           side_lyt.addWidget(QLabel("ORPHIO AGENCY", styleSheet="color: #FF9F1A; font-weight: 900; font-size: 20px;"))
â”‚   â”‚   
â”‚   â”‚           side_lyt.addWidget(QLabel("SONG CONCEPT", objectName="SectionHeader"))
â”‚   â”‚           self.input_topic = QPlainTextEdit(objectName="TopicInput")
â”‚   â”‚           self.input_topic.setPlaceholderText("Enter detailed story (7 Rows)...")
â”‚   â”‚           self.input_topic.setFixedHeight(160)
â”‚   â”‚           side_lyt.addWidget(self.input_topic)
â”‚   â”‚   
â”‚   â”‚           side_lyt.addWidget(QLabel("TAG STRATEGY", objectName="SectionHeader"))
â”‚   â”‚           self.combo_strat = QComboBox()
â”‚   â”‚           self.combo_strat.addItems(["AI GENERATED", "USER DEFINED", "MIXED"])
â”‚   â”‚           side_lyt.addWidget(self.combo_strat)
â”‚   â”‚   
â”‚   â”‚           tag_row = QHBoxLayout()
â”‚   â”‚           self.input_manual = QLineEdit(placeholderText="Manual tags...")
â”‚   â”‚           btn_lib = QPushButton("LIB", objectName="SecondaryBtn")
â”‚   â”‚           btn_lib.setFixedWidth(50);
â”‚   â”‚           btn_lib.clicked.connect(self.open_tag_library)
â”‚   â”‚           tag_row.addWidget(self.input_manual);
â”‚   â”‚           tag_row.addWidget(btn_lib)
â”‚   â”‚           side_lyt.addLayout(tag_row)
â”‚   â”‚   
â”‚   â”‚           self.btn_draft = QPushButton("1. DRAFT LYRICS", objectName="PrimaryBtn")
â”‚   â”‚           self.btn_draft.clicked.connect(self.run_draft_thread)
â”‚   â”‚           side_lyt.addWidget(self.btn_draft)
â”‚   â”‚   
â”‚   â”‚           # Params
â”‚   â”‚           side_lyt.addWidget(QLabel("PRODUCTION CONTROLS", objectName="SectionHeader"))
â”‚   â”‚           self.sld_dur = QSlider(Qt.Orientation.Horizontal);
â”‚   â”‚           self.sld_dur.setRange(10, 300);
â”‚   â”‚           self.sld_dur.setValue(60)
â”‚   â”‚           self.lbl_dur = QLabel("Duration: 60s");
â”‚   â”‚           self.sld_dur.valueChanged.connect(lambda v: self.lbl_dur.setText(f"Duration: {v}s"))
â”‚   â”‚           side_lyt.addWidget(self.lbl_dur);
â”‚   â”‚           side_lyt.addWidget(self.sld_dur)
â”‚   â”‚   
â”‚   â”‚           self.sld_cfg = QSlider(Qt.Orientation.Horizontal);
â”‚   â”‚           self.sld_cfg.setRange(10, 50);
â”‚   â”‚           self.sld_cfg.setValue(25)
â”‚   â”‚           self.lbl_cfg = QLabel("CFG Scale: 2.5");
â”‚   â”‚           self.sld_cfg.valueChanged.connect(lambda v: self.lbl_cfg.setText(f"CFG Scale: {v / 10.0}"))
â”‚   â”‚           side_lyt.addWidget(self.lbl_cfg);
â”‚   â”‚           side_lyt.addWidget(self.sld_cfg)
â”‚   â”‚   
â”‚   â”‚           self.sld_temp = QSlider(Qt.Orientation.Horizontal);
â”‚   â”‚           self.sld_temp.setRange(1, 15);
â”‚   â”‚           self.sld_temp.setValue(10)
â”‚   â”‚           self.lbl_temp = QLabel("Temp: 1.0");
â”‚   â”‚           self.sld_temp.valueChanged.connect(lambda v: self.lbl_temp.setText(f"Temp: {v / 10.0}"))
â”‚   â”‚           side_lyt.addWidget(self.lbl_temp);
â”‚   â”‚           side_lyt.addWidget(self.sld_temp)
â”‚   â”‚   
â”‚   â”‚           vault_header = QHBoxLayout()
â”‚   â”‚           vault_header.addWidget(QLabel("SONG VAULT", objectName="SectionHeader"))
â”‚   â”‚           btn_browse = QPushButton("ğŸ“", objectName="FolderBtn")
â”‚   â”‚           btn_browse.setFixedSize(35, 30);
â”‚   â”‚           btn_browse.clicked.connect(self.browse_vault_location)
â”‚   â”‚           vault_header.addWidget(btn_browse)
â”‚   â”‚           side_lyt.addLayout(vault_header)
â”‚   â”‚   
â”‚   â”‚           self.playlist_widget = QListWidget()
â”‚   â”‚           self.playlist_widget.itemDoubleClicked.connect(self.play_track)
â”‚   â”‚           side_lyt.addWidget(self.playlist_widget)
â”‚   â”‚   
â”‚   â”‚           self.btn_render = QPushButton("3. RENDER AUDIO", objectName="PrimaryBtn")
â”‚   â”‚           self.btn_render.clicked.connect(self.run_render_thread)
â”‚   â”‚           side_lyt.addWidget(self.btn_render)
â”‚   â”‚   
â”‚   â”‚           main_h_layout.addWidget(sidebar)
â”‚   â”‚   
â”‚   â”‚           # --- CENTER / RIGHT SPLITTER ---
â”‚   â”‚           content_splitter = QSplitter(Qt.Orientation.Horizontal)
â”‚   â”‚   
â”‚   â”‚           # --- EDITOR (CENTER) ---
â”‚   â”‚           editor_pane = QFrame(objectName="MainEditor")
â”‚   â”‚           ed_lyt = QVBoxLayout(editor_pane)
â”‚   â”‚   
â”‚   â”‚           arch_row = QHBoxLayout()
â”‚   â”‚           arch_row.addWidget(QLabel("ARCHITECT:", objectName="SectionHeader"))
â”‚   â”‚           self.combo_dec = QComboBox();
â”‚   â”‚           self.combo_dec.addItems(list(conf.DECORATOR_SCHEMAS.keys()))
â”‚   â”‚           btn_dec = QPushButton("2. DECORATE", objectName="SecondaryBtn");
â”‚   â”‚           btn_dec.clicked.connect(self.run_decorate_thread)
â”‚   â”‚           arch_row.addWidget(self.combo_dec);
â”‚   â”‚           arch_row.addWidget(btn_dec);
â”‚   â”‚           arch_row.addStretch()
â”‚   â”‚           ed_lyt.addLayout(arch_row)
â”‚   â”‚   
â”‚   â”‚           # THE MISSING EDITABLE TAGS FIELD
â”‚   â”‚           ed_lyt.addWidget(QLabel("LIVE TAGS (EDITABLE - SENT TO RENDERER)", objectName="SectionHeader"))
â”‚   â”‚           self.txt_live_tags = QLineEdit()
â”‚   â”‚           self.txt_live_tags.setObjectName("LiveTags")  # NEW: Match the CSS
â”‚   â”‚           self.txt_live_tags.setPlaceholderText("AI tags will appear here after drafting...")
â”‚   â”‚           self.txt_live_tags.setStyleSheet(
â”‚   â”‚               "background: #050505; color: #FF9F1A; font-weight: bold; border: 1px solid #27272A; padding: 10px;")
â”‚   â”‚           ed_lyt.addWidget(self.txt_live_tags)
â”‚   â”‚   
â”‚   â”‚           ed_lyt.addWidget(QLabel("ACTIVE LYRIC CANVAS", objectName="SectionHeader"))
â”‚   â”‚           self.txt_lyrics = QTextEdit();
â”‚   â”‚           self.txt_lyrics.setFont(QFont("Inter", 13))
â”‚   â”‚           ed_lyt.addWidget(self.txt_lyrics)
â”‚   â”‚   
â”‚   â”‚           self.prog = QProgressBar();
â”‚   â”‚           self.prog.setTextVisible(False);
â”‚   â”‚           self.prog.setFixedHeight(4)
â”‚   â”‚           ed_lyt.addWidget(self.prog)
â”‚   â”‚           self.txt_log = QTextEdit(readOnly=True);
â”‚   â”‚           self.txt_log.setFixedHeight(100)
â”‚   â”‚           ed_lyt.addWidget(self.txt_log)
â”‚   â”‚           content_splitter.addWidget(editor_pane)
â”‚   â”‚   
â”‚   â”‚           # --- INSPECTOR (RIGHT) ---
â”‚   â”‚           inspector_pane = QFrame()
â”‚   â”‚           inspector_pane.setMinimumWidth(450)
â”‚   â”‚           inspector_pane.setStyleSheet("background-color: #0C0C0E; border-left: 1px solid #18181B;")
â”‚   â”‚           ins_lyt = QVBoxLayout(inspector_pane)
â”‚   â”‚           ins_lyt.addWidget(QLabel("VAULT INSPECTOR", objectName="SectionHeader"))
â”‚   â”‚           self.ins_title = QLabel("Select a track...");
â”‚   â”‚           self.ins_title.setStyleSheet("color: #FF9F1A; font-weight: bold; font-size: 16px;")
â”‚   â”‚           ins_lyt.addWidget(self.ins_title)
â”‚   â”‚   
â”‚   â”‚           self.ins_lyrics = QTextEdit(readOnly=True)  # Second window for Vault lyrics
â”‚   â”‚           ins_lyt.addWidget(self.ins_lyrics)
â”‚   â”‚   
â”‚   â”‚           self.ins_tags = QLabel("N/A");
â”‚   â”‚           self.ins_tags.setWordWrap(True);
â”‚   â”‚           self.ins_tags.setStyleSheet("color: #FF9F1A; background: #050505; padding: 10px; border-radius: 4px;")
â”‚   â”‚           ins_lyt.addWidget(self.ins_tags)
â”‚   â”‚   
â”‚   â”‚           spec_grid = QGridLayout()
â”‚   â”‚           self.spec_seed = QLabel("Seed: -");
â”‚   â”‚           self.spec_cfg = QLabel("CFG: -")
â”‚   â”‚           self.spec_dur = QLabel("Time: -");
â”‚   â”‚           self.spec_temp = QLabel("Temp: -")
â”‚   â”‚           for i, lbl in enumerate([self.spec_seed, self.spec_cfg, self.spec_dur, self.spec_temp]):
â”‚   â”‚               lbl.setStyleSheet("color: #00FF7F; font-family: monospace; border-bottom: 1px solid #1A1A1A; padding: 5px;")
â”‚   â”‚               spec_grid.addWidget(lbl, i // 2, i % 2)
â”‚   â”‚           ins_lyt.addLayout(spec_grid)
â”‚   â”‚   
â”‚   â”‚           content_splitter.addWidget(inspector_pane)
â”‚   â”‚           main_h_layout.addWidget(content_splitter)
â”‚   â”‚           outer_layout.addLayout(main_h_layout)
â”‚   â”‚   
â”‚   â”‚           # Player
â”‚   â”‚           player_bar = QFrame();
â”‚   â”‚           player_bar.setFixedHeight(100)
â”‚   â”‚           p_lyt = QHBoxLayout(player_bar)
â”‚   â”‚           self.btn_play = QPushButton("â–¶");
â”‚   â”‚           self.btn_play.setFixedSize(60, 60);
â”‚   â”‚           self.btn_play.clicked.connect(self.toggle_play)
â”‚   â”‚           self.waveform = AgencyWaveform();
â”‚   â”‚           self.waveform.seek_requested.connect(self.player.setPosition)
â”‚   â”‚           self.lbl_time = QLabel("00:00 / 00:00");
â”‚   â”‚           self.lbl_time.setFixedWidth(120)
â”‚   â”‚           p_lyt.addWidget(self.btn_play);
â”‚   â”‚           p_lyt.addWidget(self.waveform, 1);
â”‚   â”‚           p_lyt.addWidget(self.lbl_time)
â”‚   â”‚           outer_layout.addWidget(player_bar)
â”‚   â”‚   
â”‚   â”‚       def log_system(self, msg):
â”‚   â”‚           self.txt_log.append(f"> {msg}");
â”‚   â”‚           self.txt_log.moveCursor(QTextCursor.MoveOperation.End)
â”‚   â”‚   
â”‚   â”‚       def refresh_playlist(self):
â”‚   â”‚           self.playlist_widget.clear()
â”‚   â”‚           if not conf.OUTPUT_DIR.exists(): return
â”‚   â”‚           for f in sorted(conf.OUTPUT_DIR.glob("*.wav"), key=os.path.getmtime, reverse=True):
â”‚   â”‚               i = QListWidgetItem(f.name);
â”‚   â”‚               i.setData(Qt.ItemDataRole.UserRole, str(f.absolute()))
â”‚   â”‚               self.playlist_widget.addItem(i)
â”‚   â”‚   
â”‚   â”‚       def browse_vault_location(self):
â”‚   â”‚           path = QFileDialog.getExistingDirectory(self, "Select Vault", str(conf.OUTPUT_DIR))
â”‚   â”‚           if path: conf.set_output_dir(path); self.refresh_playlist()
â”‚   â”‚   
â”‚   â”‚       def load_audio(self, path_str):
â”‚   â”‚           path = Path(path_str)
â”‚   â”‚           if not path.exists() or path.stat().st_size < 1000: return
â”‚   â”‚           self.player.setSource(QUrl.fromLocalFile(str(path.absolute())))
â”‚   â”‚           self.player.play()
â”‚   â”‚           json_path = path.with_suffix(".json")
â”‚   â”‚           if json_path.exists():
â”‚   â”‚               try:
â”‚   â”‚                   with open(json_path, 'r', encoding='utf-8') as f:
â”‚   â”‚                       data = json.load(f)
â”‚   â”‚                   config = data.get("configuration", {})
â”‚   â”‚                   prompt = config.get("input_prompt", {})
â”‚   â”‚                   self.ins_lyrics.setStyleSheet("line-height: 140%; padding: 15px; background: #070708;")
â”‚   â”‚                   self.ins_title.setText(data.get("provenance", {}).get("id", "Unknown"))
â”‚   â”‚                   self.ins_lyrics.setPlainText(prompt.get("lyrics", ""))
â”‚   â”‚                   self.ins_tags.setText(", ".join(prompt.get("tags", [])))
â”‚   â”‚                   self.spec_seed.setText(f"Seed: {config.get('seed')}")
â”‚   â”‚                   self.spec_cfg.setText(f"CFG: {config.get('cfg_scale')}")
â”‚   â”‚                   self.spec_dur.setText(f"Time: {config.get('duration_sec')}s")
â”‚   â”‚                   self.spec_temp.setText(f"Temp: {config.get('temperature')}")
â”‚   â”‚                   self.waveform.generate_random_shape(config.get('seed', 12345))
â”‚   â”‚               except:
â”‚   â”‚                   pass
â”‚   â”‚   
â”‚   â”‚       def play_track(self, item):
â”‚   â”‚           self.load_audio(item.data(Qt.ItemDataRole.UserRole))
â”‚   â”‚   
â”‚   â”‚       def toggle_play(self):
â”‚   â”‚           if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
â”‚   â”‚               self.player.pause()
â”‚   â”‚           else:
â”‚   â”‚               self.player.play()
â”‚   â”‚   
â”‚   â”‚       def update_play_btn_icon(self, state):
â”‚   â”‚           self.btn_play.setText("â¸" if state == QMediaPlayer.PlaybackState.PlayingState else "â–¶")
â”‚   â”‚   
â”‚   â”‚       def update_position(self, pos):
â”‚   â”‚           dur = self.player.duration()
â”‚   â”‚           self.waveform.set_progress(pos, dur)
â”‚   â”‚           cur, tot = pos // 1000, dur // 1000
â”‚   â”‚           self.lbl_time.setText(f"{cur // 60:02}:{cur % 60:02} / {tot // 60:02}:{tot % 60:02}")
â”‚   â”‚   
â”‚   â”‚       def update_duration(self, dur):
â”‚   â”‚           self.update_position(self.player.position())
â”‚   â”‚   
â”‚   â”‚       def open_tag_library(self):
â”‚   â”‚           dlg = TagSelectorDialog(self.input_manual.text(), self)
â”‚   â”‚           if dlg.exec(): self.input_manual.setText(", ".join(dlg.get_selected_tags()))
â”‚   â”‚   
â”‚   â”‚       def get_active_tags(self):
â”‚   â”‚           # We now pull from the LIVE EDITABLE box above the lyrics
â”‚   â”‚           return [t.strip().lower() for t in self.txt_live_tags.text().split(",") if t.strip()]
â”‚   â”‚   
â”‚   â”‚       def run_draft_thread(self):
â”‚   â”‚           topic = self.input_topic.toPlainText()
â”‚   â”‚           if topic: self.prog.setRange(0, 0); threading.Thread(target=self._bg_draft, args=(topic,), daemon=True).start()
â”‚   â”‚   
â”‚   â”‚       def _bg_draft(self, t):
â”‚   â”‚           try:
â”‚   â”‚               l, tags = self.engine.generate_lyrics_stage(t);
â”‚   â”‚               self.signals.finished_draft.emit(l, tags)
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.signals.error.emit(str(e))
â”‚   â”‚   
â”‚   â”‚       def on_draft_complete(self, l, t):
â”‚   â”‚           self.txt_lyrics.setPlainText(l)
â”‚   â”‚           self.txt_live_tags.setText(", ".join(t))  # FILL THE EDITABLE BOX
â”‚   â”‚           self.prog.setRange(0, 100)
â”‚   â”‚   
â”‚   â”‚       def run_decorate_thread(self):
â”‚   â”‚           l = self.txt_lyrics.toPlainText()
â”‚   â”‚           conf.CURRENT_DECORATOR_SCHEMA = self.combo_dec.currentText()
â”‚   â”‚           self.prog.setRange(0, 0);
â”‚   â”‚           threading.Thread(target=self._bg_decorate, args=(l, self.get_active_tags()), daemon=True).start()
â”‚   â”‚   
â”‚   â”‚       def _bg_decorate(self, l, t):
â”‚   â”‚           try:
â”‚   â”‚               res = self.engine.decorate_lyrics_stage(l, t);
â”‚   â”‚               self.signals.finished_decorate.emit(res)
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.signals.error.emit(str(e))
â”‚   â”‚   
â”‚   â”‚       def on_decorate_complete(self, res):
â”‚   â”‚           self.txt_lyrics.setPlainText(res);
â”‚   â”‚           self.prog.setRange(0, 100)
â”‚   â”‚   
â”‚   â”‚       def run_render_thread(self):
â”‚   â”‚           topic = self.input_topic.toPlainText()[:30] or "Untitled"
â”‚   â”‚           lyrics = self.txt_lyrics.toPlainText()
â”‚   â”‚           # GET TAGS FROM THE LIVE EDITABLE FIELD
â”‚   â”‚           tags = self.get_active_tags()
â”‚   â”‚           dur, cfg, tmp = self.sld_dur.value(), self.sld_cfg.value() / 10.0, self.sld_temp.value() / 10.0
â”‚   â”‚           self.prog.setRange(0, 0);
â”‚   â”‚           threading.Thread(target=self._bg_render, args=(topic, lyrics, tags, dur, cfg, tmp), daemon=True).start()
â”‚   â”‚   
â”‚   â”‚       def _bg_render(self, topic, lyrics, tags, duration, cfg, temp):
â”‚   â”‚           try:
â”‚   â”‚               path, ledger = self.engine.render_audio_stage(topic, lyrics, tags, duration, cfg, temp)
â”‚   â”‚               self.signals.finished_render.emit(path)
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.signals.error.emit(str(e))
â”‚   â”‚   
â”‚   â”‚       def on_render_complete(self, path):
â”‚   â”‚           self.prog.setRange(0, 100);
â”‚   â”‚           self.refresh_playlist();
â”‚   â”‚           self.load_audio(path)
â”‚   â”‚   
â”‚   â”‚       def on_error(self, e):
â”‚   â”‚           self.prog.setRange(0, 100);
â”‚   â”‚           QMessageBox.critical(self, "Error", str(e))
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       app = QApplication(sys.argv)
â”‚   â”‚       app.setStyle("Fusion")
â”‚   â”‚       win = OrphioStudio()
â”‚   â”‚       win.show()
â”‚   â”‚       sys.exit(app.exec())
â”‚   â”‚   
â”‚   â”œâ”€â”€ OrphioProductionStudio___________COMPLETE.py  [Mod: 2026-02-14 08:55:27]
â”‚   â”‚   [Content omitted: Exceeds 20000 character limit]
â”‚   â”‚   
â”‚   â”œâ”€â”€ OrphioProductionStudio___________COMPLETE2.py  [Mod: 2026-02-14 08:44:09]
â”‚   â”‚   [Content omitted: Exceeds 20000 character limit]
â”‚   â”‚   
â”‚   â”œâ”€â”€ RUN_FULL_ALBUM_PIPELINE___________start.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   import sys
â”‚   â”‚   import time
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from colorama import Fore, Style, init
â”‚   â”‚   
â”‚   â”‚   # Import your classes
â”‚   â”‚   from Blueprint_Executor import ProducerBlueprintEngine
â”‚   â”‚   from Album_Post_Processor import AlbumPostProcessor
â”‚   â”‚   from orphio_config import conf
â”‚   â”‚   
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def main():
â”‚   â”‚       print(f"\n{Fore.CYAN}{Style.BRIGHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
â”‚   â”‚       print(f"{Fore.CYAN}â•‘ {Fore.WHITE}{Style.BRIGHT}   ORPHIO ALBUM PIPELINE: PRODUCTION SELECTION         {Fore.CYAN}â•‘")
â”‚   â”‚       print(f"{Fore.CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
â”‚   â”‚   
â”‚   â”‚       executor = ProducerBlueprintEngine()
â”‚   â”‚   
â”‚   â”‚       # 1. SCAN FOR STRATEGIES
â”‚   â”‚       producers = executor.list_producers()
â”‚   â”‚   
â”‚   â”‚       if not producers:
â”‚   â”‚           print(f"{Fore.RED}âŒ No producer blueprints found in: {executor.strategies_path}")
â”‚   â”‚           return
â”‚   â”‚   
â”‚   â”‚       print(f"\n{Fore.YELLOW}SELECT YOUR LEAD PRODUCER:")
â”‚   â”‚       print(f"{Fore.LIGHTBLACK_EX}{'-' * 60}")
â”‚   â”‚   
â”‚   â”‚       for i, p in enumerate(producers):
â”‚   â”‚           p_name = p['name'] if isinstance(p, dict) else p.name
â”‚   â”‚           p_desc = p['desc'] if isinstance(p, dict) else "Strategy File"
â”‚   â”‚   
â”‚   â”‚           print(f"{Fore.GREEN}[{i + 1}] {Fore.WHITE}{Style.BRIGHT}{p_name.upper()}")
â”‚   â”‚           print(f"    {Fore.LIGHTBLACK_EX}{p_desc}")
â”‚   â”‚           print(f"{Fore.LIGHTBLACK_EX}{'-' * 60}")
â”‚   â”‚   
â”‚   â”‚       try:
â”‚   â”‚           user_input = input(f"\n{Fore.CYAN}ENTER PRODUCER NUMBER: ")
â”‚   â”‚           choice = int(user_input) - 1
â”‚   â”‚           if choice < 0 or choice >= len(producers):
â”‚   â”‚               raise ValueError
â”‚   â”‚       except ValueError:
â”‚   â”‚           print(f"{Fore.RED}Invalid selection.")
â”‚   â”‚           return
â”‚   â”‚   
â”‚   â”‚       selected_data = producers[choice]
â”‚   â”‚       blueprint_path = selected_data['path'] if isinstance(selected_data, dict) else selected_data
â”‚   â”‚       blueprint = executor.load_blueprint(blueprint_path)
â”‚   â”‚   
â”‚   â”‚       # 2. GET TOPIC
â”‚   â”‚       print(f"\n{Fore.YELLOW}ALBUM CONCEPT:")
â”‚   â”‚       topic = input(f"{Fore.WHITE}Describe the album (Story, Mood, or Theme): ")
â”‚   â”‚   
â”‚   â”‚       if not topic.strip():
â”‚   â”‚           print(f"{Fore.RED}No concept entered. Aborting.")
â”‚   â”‚           return
â”‚   â”‚   
â”‚   â”‚       # 3. GET DURATION
â”‚   â”‚       print(f"\n{Fore.YELLOW}TRACK DURATION:")
â”‚   â”‚       try:
â”‚   â”‚           dur_input = input(f"{Fore.WHITE}Enter duration per song in seconds (Default 120): ")
â”‚   â”‚           user_duration = int(dur_input) if dur_input.strip() else 120
â”‚   â”‚       except ValueError:
â”‚   â”‚           print(f"{Fore.RED}Invalid number. Defaulting to 120 seconds.")
â”‚   â”‚           user_duration = 120
â”‚   â”‚   
â”‚   â”‚       # 4. GET TRACK COUNT (NEW)
â”‚   â”‚       print(f"\n{Fore.YELLOW}TRACK COUNT:")
â”‚   â”‚       default_count = blueprint.get('executive_strategy', {}).get('track_count', 3)
â”‚   â”‚       try:
â”‚   â”‚           count_input = input(f"{Fore.WHITE}How many songs? (Default from Blueprint: {default_count}): ")
â”‚   â”‚           user_count = int(count_input) if count_input.strip() else None
â”‚   â”‚       except ValueError:
â”‚   â”‚           print(f"{Fore.RED}Invalid number. Using Blueprint default.")
â”‚   â”‚           user_count = None
â”‚   â”‚   
â”‚   â”‚       # 5. RUN GENERATION
â”‚   â”‚       p_name_display = selected_data['name'] if isinstance(selected_data, dict) else "Producer"
â”‚   â”‚       print(f"\n{Fore.MAGENTA}ğŸš€ HANDING OVER TO {p_name_display.upper()}...")
â”‚   â”‚   
â”‚   â”‚       # PASS COUNT TO EXECUTOR
â”‚   â”‚       executor.execute_album(blueprint, topic, user_duration, user_count)
â”‚   â”‚   
â”‚   â”‚       # 6. AUTO-MASTERING
â”‚   â”‚       print(f"\n{Fore.YELLOW}â³ GENERATION COMPLETE. SCANNING FOR ALBUM OUTPUT...")
â”‚   â”‚       time.sleep(2)
â”‚   â”‚   
â”‚   â”‚       all_albums = [d for d in conf.OUTPUT_DIR.glob("ALBUM_*") if d.is_dir()]
â”‚   â”‚       if not all_albums:
â”‚   â”‚           print(f"{Fore.RED}âŒ Error: No album folder found.")
â”‚   â”‚           return
â”‚   â”‚   
â”‚   â”‚       latest_album = max(all_albums, key=lambda p: p.stat().st_ctime)
â”‚   â”‚   
â”‚   â”‚       print(f"{Fore.CYAN}ğŸšï¸  MASTERING ENGINEER: Normalizing '{latest_album.name}'...")
â”‚   â”‚   
â”‚   â”‚       processor = AlbumPostProcessor(latest_album)
â”‚   â”‚       processor.process_album()
â”‚   â”‚   
â”‚   â”‚       print(f"\n{Fore.GREEN}{Style.BRIGHT}âœ… PRODUCTION CYCLE COMPLETE.")
â”‚   â”‚       print(f"{Fore.WHITE}ğŸ“‚ LOCATION: {latest_album / 'DISTRIBUTION_READY'}")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       main()
â”‚   â”‚   
â”‚   â”œâ”€â”€ SYSTEM_OVERVIEW.md  [Mod: 2026-02-14 08:46:37]
â”‚   â”‚   Content:
â”‚   â”‚   # ORPHIO PRODUCTION STUDIO - COMPLETE SYSTEM OVERVIEW
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“¦ What You're Getting
â”‚   â”‚   
â”‚   â”‚   I've created a **complete, production-ready multi-song AI music system** that addresses all your requirements:
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## âœ… Features Implemented
â”‚   â”‚   
â”‚   â”‚   ### 1. Multi-Song Album Production âœ“
â”‚   â”‚   - Full workflow from concept to rendered audio
â”‚   â”‚   - Generate 1-20 songs in a single session
â”‚   â”‚   - Professional album structure and organization
â”‚   â”‚   
â”‚   â”‚   ### 2. Album Concept Input âœ“
â”‚   â”‚   - Free-form text description
â”‚   â”‚   - Supports any genre or theme
â”‚   â”‚   - Narrative, standalone, or atmospheric styles
â”‚   â”‚   
â”‚   â”‚   ### 3. Album Architect (Strategy) Selection âœ“
â”‚   â”‚   - **Narrative Concept:** Story-driven connected songs
â”‚   â”‚   - **Hit Single Factory:** Independent catchy tracks
â”‚   â”‚   - **Lo-Fi Study Beats:** Atmospheric minimal lyrics
â”‚   â”‚   - Extensible - add your own strategies via JSON
â”‚   â”‚   
â”‚   â”‚   ### 4. Advanced Tag System âœ“
â”‚   â”‚   **Three Modes:**
â”‚   â”‚   - **AI Generated:** LLM creates all tags automatically
â”‚   â”‚   - **Manual Selection:** Choose from curated tag library
â”‚   â”‚   - **Hybrid:** Set base tags + AI refinement
â”‚   â”‚   
â”‚   â”‚   ### 5. LM Studio Model Integration âœ“
â”‚   â”‚   - **Model Scanner:** Detects available models
â”‚   â”‚   - **Capability Analysis:** Shows model strengths
â”‚   â”‚   - **Recommendations:** Suggests best model for task
â”‚   â”‚   - **One-Click Selection:** Easy model switching
â”‚   â”‚   
â”‚   â”‚   ### 6. Configurable Parameters âœ“
â”‚   â”‚   - **Track Count:** 1-20 songs per album
â”‚   â”‚   - **Duration:** 30-300 seconds per song
â”‚   â”‚   - **CFG Scale:** 1.0-3.0 guidance strength
â”‚   â”‚   - **Tag Mode:** AI/Manual/Hybrid selection
â”‚   â”‚   
â”‚   â”‚   ### 7. Lyric Review & Editing âœ“
â”‚   â”‚   - View all generated lyrics before rendering
â”‚   â”‚   - **Live Editor:** Edit lyrics in-place
â”‚   â”‚   - **Tag Editor:** Modify tags per song
â”‚   â”‚   - **Save/Revert:** Undo changes if needed
â”‚   â”‚   - Auto-save functionality
â”‚   â”‚   
â”‚   â”‚   ### 8. Flexible Rendering âœ“
â”‚   â”‚   - **Render All:** Batch process entire album
â”‚   â”‚   - **Render Individual:** Single song control
â”‚   â”‚   - **Custom Settings:** Adjust CFG/duration per render
â”‚   â”‚   - Progress tracking with status updates
â”‚   â”‚   
â”‚   â”‚   ### 9. Production Schema System âœ“
â”‚   â”‚   - **Save Configurations:** Reuse successful setups
â”‚   â”‚   - **Load Schemas:** Quick-start from saved configs
â”‚   â”‚   - **Share Schemas:** Team collaboration ready
â”‚   â”‚   - **Evaluation Tracking:** Quality notes and scores
â”‚   â”‚   
â”‚   â”‚   ### 10. Professional UI âœ“
â”‚   â”‚   - Modern dark theme
â”‚   â”‚   - Intuitive workflow
â”‚   â”‚   - Real-time log updates
â”‚   â”‚   - Progress indicators
â”‚   â”‚   - Tab-based organization
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“ Files Created
â”‚   â”‚   
â”‚   â”‚   ### Main Application
â”‚   â”‚   **OrphioProductionStudio_COMPLETE.py** (900+ lines)
â”‚   â”‚   - Complete GUI application
â”‚   â”‚   - All features integrated
â”‚   â”‚   - Production-ready
â”‚   â”‚   
â”‚   â”‚   ### Utilities
â”‚   â”‚   1. **EnhancedModelScanner.py**
â”‚   â”‚      - Scan LM Studio models
â”‚   â”‚      - Detect capabilities
â”‚   â”‚      - Provide recommendations
â”‚   â”‚   
â”‚   â”‚   2. **IndividualSongRenderer.py**
â”‚   â”‚      - Render specific songs
â”‚   â”‚      - Skip album rendering
â”‚   â”‚      - Quick testing tool
â”‚   â”‚   
â”‚   â”‚   3. **SystemSetupChecker.py**
â”‚   â”‚      - Validate environment
â”‚   â”‚      - Check dependencies
â”‚   â”‚      - Verify models
â”‚   â”‚   
â”‚   â”‚   ### Documentation
â”‚   â”‚   1. **PRODUCTION_SYSTEM_README.md**
â”‚   â”‚      - Complete user guide
â”‚   â”‚      - All features explained
â”‚   â”‚      - Troubleshooting guide
â”‚   â”‚      - Best practices
â”‚   â”‚   
â”‚   â”‚   2. **QUICK_START.md**
â”‚   â”‚      - 5-minute setup
â”‚   â”‚      - 10-minute first album
â”‚   â”‚      - Common issues solved
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ¯ How It Works
â”‚   â”‚   
â”‚   â”‚   ### Workflow Diagram
â”‚   â”‚   
â”‚   â”‚   ```
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   â”‚  User Input     â”‚
â”‚   â”‚   â”‚  - Concept      â”‚
â”‚   â”‚   â”‚  - Strategy     â”‚
â”‚   â”‚   â”‚  - Parameters   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   â”‚            â”‚
â”‚   â”‚            â–¼
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   â”‚  Draft Gen      â”‚
â”‚   â”‚   â”‚  - LLM creates  â”‚
â”‚   â”‚   â”‚    lyrics       â”‚
â”‚   â”‚   â”‚  - AI/Manual    â”‚
â”‚   â”‚   â”‚    tags         â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   â”‚            â”‚
â”‚   â”‚            â–¼
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   â”‚  Review/Edit    â”‚
â”‚   â”‚   â”‚  - Read lyrics  â”‚
â”‚   â”‚   â”‚  - Edit text    â”‚
â”‚   â”‚   â”‚  - Adjust tags  â”‚
â”‚   â”‚   â”‚  - Save drafts  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   â”‚            â”‚
â”‚   â”‚            â–¼
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   â”‚  Render         â”‚
â”‚   â”‚   â”‚  - HeartMuLa    â”‚
â”‚   â”‚   â”‚    generates    â”‚
â”‚   â”‚   â”‚    audio        â”‚
â”‚   â”‚   â”‚  - Save WAV     â”‚
â”‚   â”‚   â”‚  - Save JSON    â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   â”‚            â”‚
â”‚   â”‚            â–¼
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚   â”‚  Save Schema    â”‚
â”‚   â”‚   â”‚  - Store config â”‚
â”‚   â”‚   â”‚  - Add notes    â”‚
â”‚   â”‚   â”‚  - Reuse later  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ”§ Technical Architecture
â”‚   â”‚   
â”‚   â”‚   ### Component Integration
â”‚   â”‚   
â”‚   â”‚   ```
â”‚   â”‚   OrphioProductionStudio (GUI)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â†’ LMStudioController (Lyrics/Tags)
â”‚   â”‚       â”‚      â””â”€â†’ HTTP API to LM Studio
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â†’ ProducerBlueprintEngine (Album Gen)
â”‚   â”‚       â”‚      â”œâ”€â†’ Strategy Loader
â”‚   â”‚       â”‚      â””â”€â†’ Draft Creator
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â†’ OrphioEngine (Audio Render)
â”‚   â”‚       â”‚      â”œâ”€â†’ HeartMuLa Pipeline
â”‚   â”‚       â”‚      â””â”€â†’ Audio Post-Processing
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â†’ OrphioConfig (Settings)
â”‚   â”‚              â””â”€â†’ Paths, Prompts, Schemas
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### Data Flow
â”‚   â”‚   
â”‚   â”‚   1. **User Input** â†’ Configuration Panel
â”‚   â”‚   2. **Generate** â†’ LM Studio â†’ Draft JSON files
â”‚   â”‚   3. **Edit** â†’ Modified Draft JSON files
â”‚   â”‚   4. **Render** â†’ HeartMuLa â†’ WAV + Ledger JSON
â”‚   â”‚   5. **Save** â†’ Production Schema JSON
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“‹ Installation Steps
â”‚   â”‚   
â”‚   â”‚   ### 1. Run System Checker
â”‚   â”‚   ```bash
â”‚   â”‚   python SystemSetupChecker.py
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### 2. Fix Any Issues
â”‚   â”‚   - Install missing packages
â”‚   â”‚   - Verify GPU
â”‚   â”‚   - Check models
â”‚   â”‚   - Start LM Studio
â”‚   â”‚   
â”‚   â”‚   ### 3. Launch Application
â”‚   â”‚   ```bash
â”‚   â”‚   python OrphioProductionStudio___________COMPLETE2.py
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### 4. Create First Album
â”‚   â”‚   - Enter concept
â”‚   â”‚   - Select strategy
â”‚   â”‚   - Set parameters
â”‚   â”‚   - Generate & render
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ¨ Usage Examples
â”‚   â”‚   
â”‚   â”‚   ### Example 1: Narrative Album
â”‚   â”‚   ```
â”‚   â”‚   Concept: "A robot's journey to find love"
â”‚   â”‚   Strategy: Narrative Concept
â”‚   â”‚   Tracks: 5
â”‚   â”‚   Duration: 120s
â”‚   â”‚   Tag Mode: AI Generated
â”‚   â”‚   â†’ Creates connected story across 5 songs
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### Example 2: Hit Singles
â”‚   â”‚   ```
â”‚   â”‚   Concept: "Summer party anthems"
â”‚   â”‚   Strategy: Hit Single Factory
â”‚   â”‚   Tracks: 3
â”‚   â”‚   Duration: 180s
â”‚   â”‚   Tag Mode: Manual (Pop, Energetic, Dance)
â”‚   â”‚   â†’ Creates 3 independent party songs
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### Example 3: Study Music
â”‚   â”‚   ```
â”‚   â”‚   Concept: "Peaceful evening ambience"
â”‚   â”‚   Strategy: Lo-Fi Study Beats
â”‚   â”‚   Tracks: 8
â”‚   â”‚   Duration: 90s
â”‚   â”‚   Tag Mode: Hybrid (Ambient + AI)
â”‚   â”‚   â†’ Creates cohesive chill album
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸš€ Advanced Features
â”‚   â”‚   
â”‚   â”‚   ### Custom Producer Strategies
â”‚   â”‚   
â”‚   â”‚   Create `/PRODUCER_STRATEGIES/4_Your_Strategy.json`:
â”‚   â”‚   
â”‚   â”‚   ```json
â”‚   â”‚   {
â”‚   â”‚     "name": "Your Custom Strategy",
â”‚   â”‚     "description": "What it does",
â”‚   â”‚     "executive_strategy": {
â”‚   â”‚       "system_prompt": "You are a [role]...",
â”‚   â”‚       "track_count": 5
â”‚   â”‚     },
â”‚   â”‚     "propagation_logic": {
â”‚   â”‚       "type": "narrative|standalone|atmospheric",
â”‚   â”‚       "lyric_instruction_template": "Write {track_title}..."
â”‚   â”‚     }
â”‚   â”‚   }
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ### Model Selection Strategy
â”‚   â”‚   
â”‚   â”‚   **For Narrative Albums:**
â”‚   â”‚   - Use reasoning models (DeepSeek, Llama-70B)
â”‚   â”‚   - Better story coherence
â”‚   â”‚   - Slower but higher quality
â”‚   â”‚   
â”‚   â”‚   **For Quick Drafts:**
â”‚   â”‚   - Use fast models (Llama-8B, Phi-3)
â”‚   â”‚   - Faster generation
â”‚   â”‚   - May need more editing
â”‚   â”‚   
â”‚   â”‚   **For Creative Lyrics:**
â”‚   â”‚   - Use creative models (Lumimaid, MythoMax)
â”‚   â”‚   - More metaphors
â”‚   â”‚   - Unique phrasing
â”‚   â”‚   
â”‚   â”‚   ### Tag Optimization
â”‚   â”‚   
â”‚   â”‚   **Genre Tags (Most Important):**
â”‚   â”‚   - Always include 1 genre tag first
â”‚   â”‚   - Examples: Pop, Rock, Electronic, Jazz
â”‚   â”‚   
â”‚   â”‚   **Mood Tags (Very Important):**
â”‚   â”‚   - Add 2-3 mood tags
â”‚   â”‚   - Examples: Energetic, Melancholic, Uplifting
â”‚   â”‚   
â”‚   â”‚   **Detail Tags (Nice to Have):**
â”‚   â”‚   - Instruments, vocals, tempo
â”‚   â”‚   - Keep under 8 tags total
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ’¾ File Organization
â”‚   â”‚   
â”‚   â”‚   ```
â”‚   â”‚   GROUND_TRUTH_ComboAi/
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ AGANCY/
â”‚   â”‚   â”‚   â”œâ”€â”€ OrphioProductionStudio_COMPLETE.py â† MAIN APP
â”‚   â”‚   â”‚   â”œâ”€â”€ EnhancedModelScanner.py
â”‚   â”‚   â”‚   â”œâ”€â”€ IndividualSongRenderer.py
â”‚   â”‚   â”‚   â”œâ”€â”€ SystemSetupChecker.py
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ [Existing core files]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Blueprint_Executor.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ orphio_engine.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ lmstudio_controler.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ orphio_config.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ PRODUCER_STRATEGIES/
â”‚   â”‚   â”‚       â”œâ”€â”€ 1_Narrative_Concept.json
â”‚   â”‚   â”‚       â”œâ”€â”€ 2_Hit_Single_Factory.json
â”‚   â”‚   â”‚       â””â”€â”€ 3_Lofi_Study_Beats.json
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ outputSongs_ComboAi/
â”‚   â”‚   â”‚   â””â”€â”€ ALBUM_[Name]/
â”‚   â”‚   â”‚       â”œâ”€â”€ 00_ALBUM_MANIFEST.json
â”‚   â”‚   â”‚       â”œâ”€â”€ 01_Song_Title.wav
â”‚   â”‚   â”‚       â”œâ”€â”€ 01_Song_Title.json
â”‚   â”‚   â”‚       â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ PRODUCTION_SCHEMAS/
â”‚   â”‚       â””â”€â”€ schema_[timestamp].json
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ› Troubleshooting Matrix
â”‚   â”‚   
â”‚   â”‚   | Issue | Cause | Solution |
â”‚   â”‚   |-------|-------|----------|
â”‚   â”‚   | LM Studio error | Server not running | Start LM Studio, load model |
â”‚   â”‚   | CUDA OOM | Insufficient VRAM | Use smaller model/duration |
â”‚   â”‚   | Slow generation | Large model | Switch to 7B-8B model |
â”‚   â”‚   | Generic tags | Tagger timeout | Use Manual/Hybrid mode |
â”‚   â”‚   | No audio | Missing models | Check ckpt directory |
â”‚   â”‚   | Bad quality | Low CFG scale | Increase to 1.8-2.0 |
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“Š Performance Expectations
â”‚   â”‚   
â”‚   â”‚   ### Generation Times (Typical)
â”‚   â”‚   
â”‚   â”‚   **Draft Generation:**
â”‚   â”‚   - Small model (8B): ~1-2 min per song
â”‚   â”‚   - Large model (70B): ~5-10 min per song
â”‚   â”‚   
â”‚   â”‚   **Audio Rendering:**
â”‚   â”‚   - 60s song: ~2-3 minutes
â”‚   â”‚   - 120s song: ~3-5 minutes
â”‚   â”‚   - 180s song: ~5-7 minutes
â”‚   â”‚   
â”‚   â”‚   **Full Album (5 songs, 120s each):**
â”‚   â”‚   - Draft: ~5-10 minutes
â”‚   â”‚   - Render: ~15-25 minutes
â”‚   â”‚   - **Total: ~20-35 minutes**
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“ Best Practices
â”‚   â”‚   
â”‚   â”‚   ### 1. Testing New Setups
â”‚   â”‚   - Start with 2 songs
â”‚   â”‚   - Use 60-second duration
â”‚   â”‚   - Test one render first
â”‚   â”‚   - Verify quality before full album
â”‚   â”‚   
â”‚   â”‚   ### 2. Production Workflow
â”‚   â”‚   - Create detailed concept
â”‚   â”‚   - Review ALL lyrics before render
â”‚   â”‚   - Save schemas for good results
â”‚   â”‚   - Keep evaluation notes
â”‚   â”‚   
â”‚   â”‚   ### 3. Quality Optimization
â”‚   â”‚   - Use reasoning models for narratives
â”‚   â”‚   - Hybrid tag mode for best results
â”‚   â”‚   - Edit generic/repetitive lyrics
â”‚   â”‚   - Adjust CFG if output drifts
â”‚   â”‚   
â”‚   â”‚   ### 4. Efficiency Tips
â”‚   â”‚   - Queue multiple albums overnight
â”‚   â”‚   - Use saved schemas for similar projects
â”‚   â”‚   - Keep successful model/strategy combos
â”‚   â”‚   - Document what works
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ”® Future Enhancements
â”‚   â”‚   
â”‚   â”‚   **Possible Additions:**
â”‚   â”‚   - Real-time audio preview
â”‚   â”‚   - Automatic mixing/mastering
â”‚   â”‚   - Cloud model integration
â”‚   â”‚   - Collaborative editing
â”‚   â”‚   - Export to DAW formats
â”‚   â”‚   - Quality metrics dashboard
â”‚   â”‚   
â”‚   â”‚   **Current Limitations:**
â”‚   â”‚   - One album at a time
â”‚   â”‚   - No audio preview during edit
â”‚   â”‚   - Manual LM Studio model switching
â”‚   â”‚   - Single user (no collaboration)
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## âœ… System Validation
â”‚   â”‚   
â”‚   â”‚   Before reporting issues, verify:
â”‚   â”‚   
â”‚   â”‚   1. âœ“ System checker passes all critical tests
â”‚   â”‚   2. âœ“ LM Studio shows green "Running" status
â”‚   â”‚   3. âœ“ GPU has adequate VRAM (8GB+)
â”‚   â”‚   4. âœ“ All model files present in /ckpt
â”‚   â”‚   5. âœ“ Working internet for LM Studio API
â”‚   â”‚   6. âœ“ No antivirus blocking connections
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ“ Getting Help
â”‚   â”‚   
â”‚   â”‚   **Debug Steps:**
â”‚   â”‚   1. Run `SystemSetupChecker.py`
â”‚   â”‚   2. Check `orphio_studio.log`
â”‚   â”‚   3. Test with Quick Start example
â”‚   â”‚   4. Try Individual Song Renderer
â”‚   â”‚   5. Check model with Scanner
â”‚   â”‚   
â”‚   â”‚   **Common Quick Fixes:**
â”‚   â”‚   - Restart LM Studio
â”‚   â”‚   - Clear GPU memory
â”‚   â”‚   - Use smaller model
â”‚   â”‚   - Reduce duration
â”‚   â”‚   - Switch to Manual tags
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   ## ğŸ‰ You're All Set!
â”‚   â”‚   
â”‚   â”‚   You now have a **complete, professional AI music production system** with:
â”‚   â”‚   
â”‚   â”‚   âœ… Full workflow automation
â”‚   â”‚   âœ… Intuitive GUI
â”‚   â”‚   âœ… Multiple utilities
â”‚   â”‚   âœ… Comprehensive documentation
â”‚   â”‚   âœ… Best practices included
â”‚   â”‚   âœ… Troubleshooting guides
â”‚   â”‚   âœ… Extensible architecture
â”‚   â”‚   
â”‚   â”‚   **Start creating music today!**
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   **Files Provided:**
â”‚   â”‚   1. OrphioProductionStudio_COMPLETE.py
â”‚   â”‚   2. EnhancedModelScanner.py
â”‚   â”‚   3. IndividualSongRenderer.py
â”‚   â”‚   4. SystemSetupChecker.py
â”‚   â”‚   5. PRODUCTION_SYSTEM_README.md
â”‚   â”‚   6. QUICK_START.md
â”‚   â”‚   7. This overview document
â”‚   â”‚   
â”‚   â”‚   **Next Steps:**
â”‚   â”‚   1. Run SystemSetupChecker.py
â”‚   â”‚   2. Read QUICK_START.md
â”‚   â”‚   3. Launch OrphioProductionStudio_COMPLETE.py
â”‚   â”‚   4. Create your first album!
â”‚   â”‚   
â”‚   â”‚   ---
â”‚   â”‚   
â”‚   â”‚   *Happy creating! ğŸµâœ¨*
â”‚   â”‚   
â”‚   â”œâ”€â”€ SystemSetupChecker.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   Content:
â”‚   â”‚   # === AUTO-PATCHED: DLL Fix Import (DO NOT REMOVE) ===
â”‚   â”‚   try:
â”‚   â”‚       import windows_dll_fix
â”‚   â”‚   except ImportError:
â”‚   â”‚       import os, sys
â”‚   â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚   â”‚       if sys.platform == "win32":
â”‚   â”‚           try: 
â”‚   â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚   â”‚           except: 
â”‚   â”‚               pass
â”‚   â”‚   # === END AUTO-PATCH ===
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   ORPHIO SYSTEM SETUP CHECKER
â”‚   â”‚   ============================
â”‚   â”‚   Validates your environment before running the production studio
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   import sys
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from colorama import Fore, Style, init
â”‚   â”‚   
â”‚   â”‚   init(autoreset=True)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class SystemChecker:
â”‚   â”‚       """Comprehensive system validation"""
â”‚   â”‚       
â”‚   â”‚       def __init__(self):
â”‚   â”‚           self.checks_passed = 0
â”‚   â”‚           self.checks_failed = 0
â”‚   â”‚           self.warnings = 0
â”‚   â”‚           
â”‚   â”‚       def print_header(self):
â”‚   â”‚           """Print checker header"""
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}")
â”‚   â”‚           print(f"{Fore.CYAN}  ORPHIO PRODUCTION STUDIO - SYSTEM CHECKER")
â”‚   â”‚           print(f"{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚       
â”‚   â”‚       def check(self, name, condition, error_msg, warning=False):
â”‚   â”‚           """Perform a single check"""
â”‚   â”‚           if condition:
â”‚   â”‚               print(f"{Fore.GREEN}âœ“ {name}")
â”‚   â”‚               self.checks_passed += 1
â”‚   â”‚               return True
â”‚   â”‚           else:
â”‚   â”‚               if warning:
â”‚   â”‚                   print(f"{Fore.YELLOW}âš  {name}")
â”‚   â”‚                   print(f"{Fore.YELLOW}  Warning: {error_msg}")
â”‚   â”‚                   self.warnings += 1
â”‚   â”‚               else:
â”‚   â”‚                   print(f"{Fore.RED}âœ— {name}")
â”‚   â”‚                   print(f"{Fore.RED}  Error: {error_msg}")
â”‚   â”‚                   self.checks_failed += 1
â”‚   â”‚               return False
â”‚   â”‚       
â”‚   â”‚       def check_python_version(self):
â”‚   â”‚           """Check Python version"""
â”‚   â”‚           version = sys.version_info
â”‚   â”‚           is_ok = version.major == 3 and version.minor >= 10
â”‚   â”‚           
â”‚   â”‚           if is_ok:
â”‚   â”‚               version_str = f"{version.major}.{version.minor}.{version.micro}"
â”‚   â”‚               print(f"{Fore.GREEN}âœ“ Python Version: {version_str}")
â”‚   â”‚               self.checks_passed += 1
â”‚   â”‚           else:
â”‚   â”‚               print(f"{Fore.RED}âœ— Python Version: {version.major}.{version.minor}")
â”‚   â”‚               print(f"{Fore.RED}  Error: Python 3.10+ required")
â”‚   â”‚               self.checks_failed += 1
â”‚   â”‚           
â”‚   â”‚           return is_ok
â”‚   â”‚       
â”‚   â”‚       def check_imports(self):
â”‚   â”‚           """Check required Python packages"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking Python Dependencies:")
â”‚   â”‚           
â”‚   â”‚           packages = {
â”‚   â”‚               "PyQt6": "PyQt6",
â”‚   â”‚               "colorama": "colorama",
â”‚   â”‚               "numpy": "numpy",
â”‚   â”‚               "scipy": "scipy",
â”‚   â”‚               "torch": "torch",
â”‚   â”‚               "torchaudio": "torchaudio",
â”‚   â”‚               "requests": "requests"
â”‚   â”‚           }
â”‚   â”‚           
â”‚   â”‚           all_ok = True
â”‚   â”‚           for display_name, import_name in packages.items():
â”‚   â”‚               try:
â”‚   â”‚                   __import__(import_name)
â”‚   â”‚                   print(f"{Fore.GREEN}  âœ“ {display_name}")
â”‚   â”‚                   self.checks_passed += 1
â”‚   â”‚               except ImportError:
â”‚   â”‚                   print(f"{Fore.RED}  âœ— {display_name}")
â”‚   â”‚                   print(f"{Fore.RED}    Install: pip install {import_name}")
â”‚   â”‚                   self.checks_failed += 1
â”‚   â”‚                   all_ok = False
â”‚   â”‚           
â”‚   â”‚           return all_ok
â”‚   â”‚       
â”‚   â”‚       def check_file_structure(self):
â”‚   â”‚           """Check directory structure"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking File Structure:")
â”‚   â”‚           
â”‚   â”‚           # Find project root
â”‚   â”‚           current = Path.cwd()
â”‚   â”‚           root = None
â”‚   â”‚           
â”‚   â”‚           for parent in [current] + list(current.parents):
â”‚   â”‚               if (parent / "ckpt").exists() or (parent / "GROUND_TRUTH_ComboAi").exists():
â”‚   â”‚                   root = parent
â”‚   â”‚                   break
â”‚   â”‚           
â”‚   â”‚           if not root:
â”‚   â”‚               print(f"{Fore.RED}  âœ— Project root not found")
â”‚   â”‚               print(f"{Fore.RED}    Cannot locate ckpt or GROUND_TRUTH_ComboAi folder")
â”‚   â”‚               self.checks_failed += 1
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           print(f"{Fore.GREEN}  âœ“ Project root: {root}")
â”‚   â”‚           self.checks_passed += 1
â”‚   â”‚           
â”‚   â”‚           # Check key directories
â”‚   â”‚           required_dirs = {
â”‚   â”‚               "ckpt": "Model checkpoint directory",
â”‚   â”‚               "GROUND_TRUTH_ComboAi": "Project directory",
â”‚   â”‚               "GROUND_TRUTH_ComboAi/AGANCY": "Core scripts location"
â”‚   â”‚           }
â”‚   â”‚           
â”‚   â”‚           all_ok = True
â”‚   â”‚           for dir_name, description in required_dirs.items():
â”‚   â”‚               dir_path = root / dir_name
â”‚   â”‚               if self.check(
â”‚   â”‚                   f"  {description}",
â”‚   â”‚                   dir_path.exists() and dir_path.is_dir(),
â”‚   â”‚                   f"Missing: {dir_path}"
â”‚   â”‚               ):
â”‚   â”‚                   pass
â”‚   â”‚               else:
â”‚   â”‚                   all_ok = False
â”‚   â”‚           
â”‚   â”‚           return all_ok
â”‚   â”‚       
â”‚   â”‚       def check_models(self):
â”‚   â”‚           """Check HeartMuLa models"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking HeartMuLa Models:")
â”‚   â”‚           
â”‚   â”‚           # Find ckpt directory
â”‚   â”‚           current = Path.cwd()
â”‚   â”‚           ckpt_dir = None
â”‚   â”‚           
â”‚   â”‚           for parent in [current] + list(current.parents):
â”‚   â”‚               test_ckpt = parent / "ckpt"
â”‚   â”‚               if test_ckpt.exists():
â”‚   â”‚                   ckpt_dir = test_ckpt
â”‚   â”‚                   break
â”‚   â”‚           
â”‚   â”‚           if not ckpt_dir:
â”‚   â”‚               print(f"{Fore.RED}  âœ— ckpt directory not found")
â”‚   â”‚               self.checks_failed += 1
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           # Check required models
â”‚   â”‚           required_items = {
â”‚   â”‚               "HeartMuLa-oss-3B": "Brain model",
â”‚   â”‚               "HeartCodec-oss": "Vocoder model",
â”‚   â”‚               "tokenizer.json": "Tokenizer",
â”‚   â”‚               "gen_config.json": "Generation config"
â”‚   â”‚           }
â”‚   â”‚           
â”‚   â”‚           all_ok = True
â”‚   â”‚           for item_name, description in required_items.items():
â”‚   â”‚               item_path = ckpt_dir / item_name
â”‚   â”‚               if self.check(
â”‚   â”‚                   f"  {description}",
â”‚   â”‚                   item_path.exists(),
â”‚   â”‚                   f"Missing: {item_path}"
â”‚   â”‚               ):
â”‚   â”‚                   # Show size for directories
â”‚   â”‚                   if item_path.is_dir():
â”‚   â”‚                       size_mb = sum(f.stat().st_size for f in item_path.rglob('*') if f.is_file()) / (1024**2)
â”‚   â”‚                       print(f"{Fore.CYAN}    Size: {size_mb:.1f} MB")
â”‚   â”‚               else:
â”‚   â”‚                   all_ok = False
â”‚   â”‚           
â”‚   â”‚           return all_ok
â”‚   â”‚       
â”‚   â”‚       def check_lm_studio(self):
â”‚   â”‚           """Check LM Studio connection"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking LM Studio:")
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               import requests
â”‚   â”‚               response = requests.get("http://localhost:1234/v1/models", timeout=3)
â”‚   â”‚               
â”‚   â”‚               if response.status_code == 200:
â”‚   â”‚                   data = response.json()
â”‚   â”‚                   if data.get('data'):
â”‚   â”‚                       model_id = data['data'][0].get('id', 'unknown')
â”‚   â”‚                       print(f"{Fore.GREEN}  âœ“ LM Studio connected")
â”‚   â”‚                       print(f"{Fore.CYAN}    Active model: {model_id}")
â”‚   â”‚                       self.checks_passed += 1
â”‚   â”‚                       return True
â”‚   â”‚           except:
â”‚   â”‚               pass
â”‚   â”‚           
â”‚   â”‚           print(f"{Fore.YELLOW}  âš  LM Studio not connected")
â”‚   â”‚           print(f"{Fore.YELLOW}    Start LM Studio and load a model before running")
â”‚   â”‚           self.warnings += 1
â”‚   â”‚           return False
â”‚   â”‚       
â”‚   â”‚       def check_gpu(self):
â”‚   â”‚           """Check GPU availability"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking GPU:")
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               import torch
â”‚   â”‚               
â”‚   â”‚               if torch.cuda.is_available():
â”‚   â”‚                   device = torch.cuda.get_device_properties(0)
â”‚   â”‚                   vram_gb = device.total_memory / (1024**3)
â”‚   â”‚                   
â”‚   â”‚                   print(f"{Fore.GREEN}  âœ“ GPU detected: {device.name}")
â”‚   â”‚                   print(f"{Fore.CYAN}    VRAM: {vram_gb:.1f} GB")
â”‚   â”‚                   
â”‚   â”‚                   # Check if adequate for audio generation
â”‚   â”‚                   if vram_gb >= 8:
â”‚   â”‚                       print(f"{Fore.GREEN}    Adequate for audio generation")
â”‚   â”‚                       self.checks_passed += 1
â”‚   â”‚                   else:
â”‚   â”‚                       print(f"{Fore.YELLOW}    Low VRAM - may have issues")
â”‚   â”‚                       print(f"{Fore.YELLOW}    Recommended: 8GB+ for HeartMuLa")
â”‚   â”‚                       self.warnings += 1
â”‚   â”‚                   
â”‚   â”‚                   return True
â”‚   â”‚               else:
â”‚   â”‚                   print(f"{Fore.RED}  âœ— No CUDA GPU detected")
â”‚   â”‚                   print(f"{Fore.RED}    GPU required for audio generation")
â”‚   â”‚                   self.checks_failed += 1
â”‚   â”‚                   return False
â”‚   â”‚           
â”‚   â”‚           except ImportError:
â”‚   â”‚               print(f"{Fore.RED}  âœ— PyTorch not installed")
â”‚   â”‚               self.checks_failed += 1
â”‚   â”‚               return False
â”‚   â”‚       
â”‚   â”‚       def check_config_files(self):
â”‚   â”‚           """Check configuration files"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking Configuration:")
â”‚   â”‚           
â”‚   â”‚           # Find AGANCY directory
â”‚   â”‚           current = Path.cwd()
â”‚   â”‚           agancy_dir = None
â”‚   â”‚           
â”‚   â”‚           for parent in [current] + list(current.parents):
â”‚   â”‚               test_agancy = parent / "GROUND_TRUTH_ComboAi" / "AGANCY"
â”‚   â”‚               if test_agancy.exists():
â”‚   â”‚                   agancy_dir = test_agancy
â”‚   â”‚                   break
â”‚   â”‚           
â”‚   â”‚           if not agancy_dir:
â”‚   â”‚               print(f"{Fore.RED}  âœ— AGANCY directory not found")
â”‚   â”‚               self.checks_failed += 1
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           # Check key files
â”‚   â”‚           key_files = {
â”‚   â”‚               "orphio_config.py": "Configuration",
â”‚   â”‚               "orphio_engine.py": "Audio engine",
â”‚   â”‚               "lmstudio_controler.py": "LLM controller",
â”‚   â”‚               "Blueprint_Executor.py": "Album generator",
â”‚   â”‚               "tags.json": "Tag library"
â”‚   â”‚           }
â”‚   â”‚           
â”‚   â”‚           all_ok = True
â”‚   â”‚           for filename, description in key_files.items():
â”‚   â”‚               filepath = agancy_dir / filename
â”‚   â”‚               if not self.check(
â”‚   â”‚                   f"  {description}",
â”‚   â”‚                   filepath.exists(),
â”‚   â”‚                   f"Missing: {filepath}"
â”‚   â”‚               ):
â”‚   â”‚                   all_ok = False
â”‚   â”‚           
â”‚   â”‚           return all_ok
â”‚   â”‚       
â”‚   â”‚       def check_producer_strategies(self):
â”‚   â”‚           """Check producer strategy files"""
â”‚   â”‚           print(f"\n{Fore.WHITE}Checking Producer Strategies:")
â”‚   â”‚           
â”‚   â”‚           # Find strategies directory
â”‚   â”‚           current = Path.cwd()
â”‚   â”‚           strategies_dir = None
â”‚   â”‚           
â”‚   â”‚           for parent in [current] + list(current.parents):
â”‚   â”‚               test_dir = parent / "GROUND_TRUTH_ComboAi" / "AGANCY" / "PRODUCER_STRATEGIES"
â”‚   â”‚               if test_dir.exists():
â”‚   â”‚                   strategies_dir = test_dir
â”‚   â”‚                   break
â”‚   â”‚           
â”‚   â”‚           if not strategies_dir:
â”‚   â”‚               print(f"{Fore.YELLOW}  âš  PRODUCER_STRATEGIES directory not found")
â”‚   â”‚               self.warnings += 1
â”‚   â”‚               return False
â”‚   â”‚           
â”‚   â”‚           # Count strategy files
â”‚   â”‚           strategy_files = list(strategies_dir.glob("*.json"))
â”‚   â”‚           
â”‚   â”‚           if strategy_files:
â”‚   â”‚               print(f"{Fore.GREEN}  âœ“ Found {len(strategy_files)} strategies")
â”‚   â”‚               for strategy_file in strategy_files:
â”‚   â”‚                   print(f"{Fore.CYAN}    - {strategy_file.name}")
â”‚   â”‚               self.checks_passed += 1
â”‚   â”‚               return True
â”‚   â”‚           else:
â”‚   â”‚               print(f"{Fore.YELLOW}  âš  No strategy files found")
â”‚   â”‚               self.warnings += 1
â”‚   â”‚               return False
â”‚   â”‚       
â”‚   â”‚       def print_summary(self):
â”‚   â”‚           """Print check summary"""
â”‚   â”‚           print(f"\n{Fore.CYAN}{'=' * 70}")
â”‚   â”‚           print(f"{Fore.WHITE}SUMMARY:")
â”‚   â”‚           print(f"  {Fore.GREEN}Passed:  {self.checks_passed}")
â”‚   â”‚           print(f"  {Fore.YELLOW}Warnings: {self.warnings}")
â”‚   â”‚           print(f"  {Fore.RED}Failed:  {self.checks_failed}")
â”‚   â”‚           
â”‚   â”‚           print(f"\n{Fore.WHITE}Status: ", end="")
â”‚   â”‚           if self.checks_failed == 0:
â”‚   â”‚               if self.warnings == 0:
â”‚   â”‚                   print(f"{Fore.GREEN}âœ“ ALL CHECKS PASSED - READY TO RUN")
â”‚   â”‚                   print(f"\n{Fore.CYAN}Run the production studio:")
â”‚   â”‚                   print(f"{Fore.WHITE}  python OrphioProductionStudio_COMPLETE.py")
â”‚   â”‚               else:
â”‚   â”‚                   print(f"{Fore.YELLOW}âš  READY WITH WARNINGS")
â”‚   â”‚                   print(f"{Fore.YELLOW}  System will work but may have issues")
â”‚   â”‚           else:
â”‚   â”‚               print(f"{Fore.RED}âœ— CRITICAL ISSUES FOUND")
â”‚   â”‚               print(f"{Fore.RED}  Fix errors before running")
â”‚   â”‚           
â”‚   â”‚           print(f"{Fore.CYAN}{'=' * 70}\n")
â”‚   â”‚       
â”‚   â”‚       def run_all_checks(self):
â”‚   â”‚           """Run all system checks"""
â”‚   â”‚           self.print_header()
â”‚   â”‚           
â”‚   â”‚           # Core checks
â”‚   â”‚           self.check_python_version()
â”‚   â”‚           self.check_imports()
â”‚   â”‚           self.check_file_structure()
â”‚   â”‚           self.check_config_files()
â”‚   â”‚           
â”‚   â”‚           # Model checks
â”‚   â”‚           self.check_models()
â”‚   â”‚           
â”‚   â”‚           # Runtime checks
â”‚   â”‚           self.check_gpu()
â”‚   â”‚           self.check_lm_studio()
â”‚   â”‚           
â”‚   â”‚           # Optional checks
â”‚   â”‚           self.check_producer_strategies()
â”‚   â”‚           
â”‚   â”‚           # Summary
â”‚   â”‚           self.print_summary()
â”‚   â”‚           
â”‚   â”‚           return self.checks_failed == 0
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def main():
â”‚   â”‚       """Run system checker"""
â”‚   â”‚       checker = SystemChecker()
â”‚   â”‚       success = checker.run_all_checks()
â”‚   â”‚       
â”‚   â”‚       sys.exit(0 if success else 1)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       main()
â”‚   â”‚   
â”‚   â”œâ”€â”€ tags.json  [Mod: 2026-02-14 06:38:03]
â”‚   â”‚   Content:
â”‚   â”‚   {
â”‚   â”‚       "1_GENRE_95%": [
â”‚   â”‚           "Pop", "Rock", "Electronic", "Hip Hop", "Jazz", "Classical",
â”‚   â”‚           "Techno", "Trance", "Ambient", "Folk", "Country", "Metal", 
â”‚   â”‚           "R&B", "Soul", "Funk", "Disco", "Reggae", "Blues", "Indie",
â”‚   â”‚           "Alternative", "Punk", "Grunge", "EDM", "House", "Dubstep",
â”‚   â”‚           "Trap", "Lo-fi", "Chillwave", "Synthwave", "Vaporwave"
â”‚   â”‚       ],
â”‚   â”‚       "2_TIMBRE_50%": [
â”‚   â”‚           "Soft", "Warm", "Husky", "Bright", "Dark", "Distorted", 
â”‚   â”‚           "Clean", "Muffled", "Crisp", "Raspy", "Smooth", "Breathy",
â”‚   â”‚           "Powerful", "Delicate", "Rich", "Thin", "Full", "Airy"
â”‚   â”‚       ],
â”‚   â”‚       "3_GENDER_37%": [
â”‚   â”‚           "Male Vocals", "Female Vocals", "Mixed Vocals", "Choir",
â”‚   â”‚           "Spoken Word", "Rap", "Falsetto", "Baritone", "Soprano"
â”‚   â”‚       ],
â”‚   â”‚       "4_MOOD_32%": [
â”‚   â”‚           "Happy", "Sad", "Energetic", "Joyful", "Melancholic",
â”‚   â”‚           "Relaxing", "Dark", "Epic", "Romantic", "Sentimental",
â”‚   â”‚           "Angry", "Peaceful", "Anxious", "Hopeful", "Nostalgic",
â”‚   â”‚           "Triumphant", "Mysterious", "Playful", "Somber", "Uplifting",
â”‚   â”‚           "Bittersweet", "Dreamy", "Intense", "Calm", "Aggressive"
â”‚   â”‚       ],
â”‚   â”‚       "5_INSTRUMENT_25%": [
â”‚   â”‚           "Piano", "Synthesizer", "Acoustic Guitar", "Electric Guitar",
â”‚   â”‚           "Bass", "Drums", "Strings", "Violin", "Drum Machine",
â”‚   â”‚           "808", "Saxophone", "Trumpet", "Flute", "Organ",
â”‚   â”‚           "Harmonica", "Banjo", "Ukulele", "Cello", "Harp",
â”‚   â”‚           "Steel Drums", "Percussion", "Brass", "Woodwinds"
â”‚   â”‚       ],
â”‚   â”‚       "6_SCENE_20%": [
â”‚   â”‚           "Dance", "Workout", "Dating", "Study", "Cinematic", 
â”‚   â”‚           "Party", "Cafe", "Driving", "Meditation", "Sleep",
â”‚   â”‚           "Gaming", "Cooking", "Road Trip", "Beach", "Rainy Day",
â”‚   â”‚           "Sunrise", "Sunset", "Night Out", "Chill Session"
â”‚   â”‚       ],
â”‚   â”‚       "7_TOPIC_10%": [
â”‚   â”‚           "Love", "Summer", "Heartbreak", "Faith", "Youthful", 
â”‚   â”‚           "Struggle", "Reflection", "Freedom", "Loss", "Hope",
â”‚   â”‚           "Adventure", "Dreams", "Rebellion", "Nature", "City Life",
â”‚   â”‚           "Memories", "Change", "Identity", "Justice", "Time"
â”‚   â”‚       ],
â”‚   â”‚       "8_PRODUCTION_15%": [
â”‚   â”‚           "Lo-fi", "Hi-fi", "Reverb-heavy", "Dry", "Compressed",
â”‚   â”‚           "Dynamic", "Minimal", "Layered", "Stripped", "Polished",
â”‚   â”‚           "Raw", "Atmospheric", "Punchy", "Spacious", "Tight"
â”‚   â”‚       ],
â”‚   â”‚       "9_TEMPO_28%": [
â”‚   â”‚           "Slow", "Mid-tempo", "Up-tempo", "Fast", "Very Fast",
â”‚   â”‚           "Ballad", "Downtempo", "Moderate", "Accelerating"
â”‚   â”‚       ],
â”‚   â”‚       "10_STYLE_18%": [
â”‚   â”‚           "Retro", "Modern", "Vintage", "Futuristic", "Minimalist",
â”‚   â”‚           "Maximalist", "Experimental", "Traditional", "Fusion",
â”‚   â”‚           "Crossover", "Underground", "Mainstream", "Art Pop"
â”‚   â”‚       ]
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”œâ”€â”€ tagSelector.py  [Mod: 2026-02-14 07:07:12]
â”‚   â”‚   Content:
â”‚   â”‚   import json
â”‚   â”‚   import sys
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from typing import List
â”‚   â”‚   from PyQt6.QtWidgets import (
â”‚   â”‚       QApplication, QDialog, QVBoxLayout, QScrollArea, QWidget,
â”‚   â”‚       QCheckBox, QPushButton, QLineEdit, QGridLayout,
â”‚   â”‚       QSizePolicy, QLabel, QHBoxLayout, QFrame
â”‚   â”‚   )
â”‚   â”‚   from PyQt6.QtCore import Qt
â”‚   â”‚   
â”‚   â”‚   # === COMPACT & PROFESSIONAL STYLESHEET ===
â”‚   â”‚   COMPACT_TAG_STYLES = """
â”‚   â”‚   /* MAIN DIALOG */
â”‚   â”‚   QDialog { 
â”‚   â”‚       background-color: #0A0A0C; 
â”‚   â”‚       color: #E4E4E7;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* SEARCH BAR */
â”‚   â”‚   QLineEdit {
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       border: 1px solid #3F3F46;
â”‚   â”‚       border-radius: 6px;
â”‚   â”‚       padding: 10px 16px;
â”‚   â”‚       color: #FFFFFF;
â”‚   â”‚       font-size: 13px;
â”‚   â”‚       font-weight: 500;
â”‚   â”‚   }
â”‚   â”‚   QLineEdit:focus { 
â”‚   â”‚       border: 1px solid #00FF7F; 
â”‚   â”‚   }
â”‚   â”‚   QLineEdit::placeholder {
â”‚   â”‚       color: #52525B;
â”‚   â”‚       font-style: italic;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* SCROLL AREA */
â”‚   â”‚   QScrollArea { 
â”‚   â”‚       border: none; 
â”‚   â”‚       background-color: transparent; 
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* CATEGORY HEADERS - MORE COMPACT */
â”‚   â”‚   QLabel#CategoryHeader {
â”‚   â”‚       color: #00FF7F;
â”‚   â”‚       font-size: 10px;
â”‚   â”‚       font-weight: 800;
â”‚   â”‚       letter-spacing: 1.5px;
â”‚   â”‚       background-color: transparent;
â”‚   â”‚       padding: 8px 0px 4px 0px;
â”‚   â”‚       margin-top: 12px;
â”‚   â”‚       border-bottom: 2px solid #27272A;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* TAG CHECKBOXES - COMPACT TILES */
â”‚   â”‚   QCheckBox {
â”‚   â”‚       color: #D4D4D8;
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       border: 1px solid #27272A;
â”‚   â”‚       border-radius: 4px;
â”‚   â”‚       padding: 8px 12px;
â”‚   â”‚       font-size: 12px;
â”‚   â”‚       font-weight: 500;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   QCheckBox::indicator {
â”‚   â”‚       width: 0px;
â”‚   â”‚       height: 0px;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   QCheckBox:hover {
â”‚   â”‚       background-color: #27272A;
â”‚   â”‚       color: #FFFFFF;
â”‚   â”‚       border: 1px solid #52525B;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   QCheckBox:checked {
â”‚   â”‚       background-color: #00FF7F;
â”‚   â”‚       color: #000000;
â”‚   â”‚       border: 1px solid #00FF7F;
â”‚   â”‚       font-weight: 700;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* BUTTONS - COMPACT */
â”‚   â”‚   QPushButton#PrimaryBtn {
â”‚   â”‚       background-color: #00FF7F;
â”‚   â”‚       color: #000000;
â”‚   â”‚       border: none;
â”‚   â”‚       border-radius: 6px;
â”‚   â”‚       font-weight: 900;
â”‚   â”‚       font-size: 13px;
â”‚   â”‚       padding: 12px;
â”‚   â”‚       text-transform: uppercase;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#PrimaryBtn:hover { 
â”‚   â”‚       background-color: #00E672; 
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   QPushButton#SecondaryBtn {
â”‚   â”‚       background-color: #27272A;
â”‚   â”‚       color: #A1A1AA;
â”‚   â”‚       border: 1px solid #3F3F46;
â”‚   â”‚       border-radius: 4px;
â”‚   â”‚       padding: 6px 12px;
â”‚   â”‚       font-size: 11px;
â”‚   â”‚       font-weight: 600;
â”‚   â”‚   }
â”‚   â”‚   QPushButton#SecondaryBtn:hover { 
â”‚   â”‚       color: #FFFFFF; 
â”‚   â”‚       background-color: #3F3F46;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* FOOTER */
â”‚   â”‚   QFrame#Footer {
â”‚   â”‚       background-color: #111113;
â”‚   â”‚       border-top: 1px solid #27272A;
â”‚   â”‚       padding: 12px;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   QLabel#SelectionLabel {
â”‚   â”‚       color: #71717A;
â”‚   â”‚       font-size: 11px;
â”‚   â”‚       padding: 8px;
â”‚   â”‚       background-color: #18181B;
â”‚   â”‚       border-radius: 4px;
â”‚   â”‚       border-left: 2px solid #00FF7F;
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   /* SCROLLBAR - THIN */
â”‚   â”‚   QScrollBar:vertical {
â”‚   â”‚       background: transparent; 
â”‚   â”‚       width: 8px;
â”‚   â”‚   }
â”‚   â”‚   QScrollBar::handle:vertical {
â”‚   â”‚       background: #3F3F46; 
â”‚   â”‚       min-height: 30px; 
â”‚   â”‚       border-radius: 4px;
â”‚   â”‚   }
â”‚   â”‚   QScrollBar::handle:vertical:hover { 
â”‚   â”‚       background: #52525B; 
â”‚   â”‚   }
â”‚   â”‚   QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { 
â”‚   â”‚       height: 0px; 
â”‚   â”‚   }
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class TagSelectorDialog(QDialog):
â”‚   â”‚       """Compact, professional tag library"""
â”‚   â”‚   
â”‚   â”‚       def __init__(self, current_tags_str="", parent=None):
â”‚   â”‚           super().__init__(parent)
â”‚   â”‚           self.setWindowTitle("Tag Library")
â”‚   â”‚   
â”‚   â”‚           # MUCH SMALLER SIZE
â”‚   â”‚           self.resize(1000, 700)
â”‚   â”‚           self.setMinimumSize(900, 600)
â”‚   â”‚   
â”‚   â”‚           self.initially_selected = [t.strip().lower() for t in current_tags_str.split(",") if t.strip()]
â”‚   â”‚           self.checkboxes = []
â”‚   â”‚           self.category_widgets = []
â”‚   â”‚   
â”‚   â”‚           self.setStyleSheet(COMPACT_TAG_STYLES)
â”‚   â”‚           self.init_ui()
â”‚   â”‚           self.load_tags()
â”‚   â”‚   
â”‚   â”‚       def init_ui(self):
â”‚   â”‚           """Initialize compact UI"""
â”‚   â”‚           layout = QVBoxLayout(self)
â”‚   â”‚           layout.setContentsMargins(20, 20, 20, 20)
â”‚   â”‚           layout.setSpacing(12)
â”‚   â”‚   
â”‚   â”‚           # COMPACT HEADER
â”‚   â”‚           header = QHBoxLayout()
â”‚   â”‚   
â”‚   â”‚           title = QLabel("TAG LIBRARY")
â”‚   â”‚           title.setStyleSheet("color: #00FF7F; font-weight: 900; font-size: 18px; letter-spacing: 2px;")
â”‚   â”‚           header.addWidget(title)
â”‚   â”‚   
â”‚   â”‚           header.addStretch()
â”‚   â”‚   
â”‚   â”‚           btn_clear = QPushButton("Clear All")
â”‚   â”‚           btn_clear.setObjectName("SecondaryBtn")
â”‚   â”‚           btn_clear.clicked.connect(self.clear_all)
â”‚   â”‚           header.addWidget(btn_clear)
â”‚   â”‚   
â”‚   â”‚           layout.addLayout(header)
â”‚   â”‚   
â”‚   â”‚           # COMPACT SEARCH
â”‚   â”‚           self.search_input = QLineEdit()
â”‚   â”‚           self.search_input.setPlaceholderText("Filter tags... (e.g. 'Dark', 'Pop', '95%')")
â”‚   â”‚           self.search_input.textChanged.connect(self.filter_tags)
â”‚   â”‚           layout.addWidget(self.search_input)
â”‚   â”‚   
â”‚   â”‚           # SCROLLABLE TAG AREA
â”‚   â”‚           self.scroll = QScrollArea()
â”‚   â”‚           self.scroll.setWidgetResizable(True)
â”‚   â”‚           self.scroll.setFrameShape(QFrame.Shape.NoFrame)
â”‚   â”‚           self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
â”‚   â”‚   
â”‚   â”‚           self.container = QWidget()
â”‚   â”‚           self.main_layout = QVBoxLayout(self.container)
â”‚   â”‚           self.main_layout.setSpacing(8)
â”‚   â”‚           self.main_layout.setContentsMargins(0, 0, 10, 0)
â”‚   â”‚   
â”‚   â”‚           self.scroll.setWidget(self.container)
â”‚   â”‚           layout.addWidget(self.scroll, 1)
â”‚   â”‚   
â”‚   â”‚           # COMPACT FOOTER
â”‚   â”‚           footer = QFrame()
â”‚   â”‚           footer.setObjectName("Footer")
â”‚   â”‚           footer_layout = QVBoxLayout(footer)
â”‚   â”‚           footer_layout.setContentsMargins(0, 0, 0, 0)
â”‚   â”‚           footer_layout.setSpacing(10)
â”‚   â”‚   
â”‚   â”‚           self.selection_label = QLabel("No tags selected")
â”‚   â”‚           self.selection_label.setObjectName("SelectionLabel")
â”‚   â”‚           self.selection_label.setWordWrap(True)
â”‚   â”‚           footer_layout.addWidget(self.selection_label)
â”‚   â”‚   
â”‚   â”‚           self.apply_btn = QPushButton("Apply Selection")
â”‚   â”‚           self.apply_btn.setObjectName("PrimaryBtn")
â”‚   â”‚           self.apply_btn.clicked.connect(self.accept)
â”‚   â”‚           footer_layout.addWidget(self.apply_btn)
â”‚   â”‚   
â”‚   â”‚           layout.addWidget(footer)
â”‚   â”‚   
â”‚   â”‚       def load_tags(self):
â”‚   â”‚           """Load tags from JSON"""
â”‚   â”‚           path = Path(__file__).parent / "tags.json"
â”‚   â”‚           if not path.exists():
â”‚   â”‚               return
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               with open(path, 'r', encoding='utf-8') as f:
â”‚   â”‚                   data = json.load(f)
â”‚   â”‚   
â”‚   â”‚               for cat_key in sorted(data.keys()):
â”‚   â”‚                   # Clean up category name
â”‚   â”‚                   clean_name = cat_key.split('_', 1)[-1].replace('_', ' ').upper()
â”‚   â”‚                   # Extract percentage if present
â”‚   â”‚                   if '%' in cat_key:
â”‚   â”‚                       percentage = cat_key.split('_')[0].split()[-1]
â”‚   â”‚                       clean_name = f"{clean_name} â€¢ {percentage}"
â”‚   â”‚   
â”‚   â”‚                   self._create_category_block(clean_name, data[cat_key])
â”‚   â”‚   
â”‚   â”‚               self.main_layout.addStretch(1)
â”‚   â”‚               self.update_ui_state()
â”‚   â”‚   
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print(f"Error loading tags: {e}")
â”‚   â”‚   
â”‚   â”‚       def _create_category_block(self, category_name: str, tags: List[str]):
â”‚   â”‚           """Create compact category with tags"""
â”‚   â”‚           cat_widget = QWidget()
â”‚   â”‚           cat_layout = QVBoxLayout(cat_widget)
â”‚   â”‚           cat_layout.setContentsMargins(0, 0, 0, 0)
â”‚   â”‚           cat_layout.setSpacing(8)
â”‚   â”‚   
â”‚   â”‚           # Category header
â”‚   â”‚           header = QLabel(category_name)
â”‚   â”‚           header.setObjectName("CategoryHeader")
â”‚   â”‚           cat_layout.addWidget(header)
â”‚   â”‚   
â”‚   â”‚           # Tag grid - MORE TAGS PER ROW (6 instead of 5)
â”‚   â”‚           grid = QGridLayout()
â”‚   â”‚           grid.setContentsMargins(0, 0, 0, 0)
â”‚   â”‚           grid.setSpacing(6)
â”‚   â”‚   
â”‚   â”‚           cols = 6  # 6 tags per row for compact view
â”‚   â”‚   
â”‚   â”‚           for i, tag in enumerate(tags):
â”‚   â”‚               cb = QCheckBox(tag)
â”‚   â”‚               cb.setCursor(Qt.CursorShape.PointingHandCursor)
â”‚   â”‚               cb.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
â”‚   â”‚   
â”‚   â”‚               if tag.lower() in self.initially_selected:
â”‚   â”‚                   cb.setChecked(True)
â”‚   â”‚   
â”‚   â”‚               cb.stateChanged.connect(self.update_ui_state)
â”‚   â”‚               cb.category = category_name
â”‚   â”‚               cb.tag_text = tag.lower()
â”‚   â”‚   
â”‚   â”‚               self.checkboxes.append(cb)
â”‚   â”‚               grid.addWidget(cb, i // cols, i % cols)
â”‚   â”‚   
â”‚   â”‚           cat_layout.addLayout(grid)
â”‚   â”‚   
â”‚   â”‚           self.main_layout.addWidget(cat_widget)
â”‚   â”‚           self.category_widgets.append((cat_widget, category_name))
â”‚   â”‚   
â”‚   â”‚       def filter_tags(self, text: str):
â”‚   â”‚           """Filter tags"""
â”‚   â”‚           search = text.lower()
â”‚   â”‚   
â”‚   â”‚           if not search:
â”‚   â”‚               for cb in self.checkboxes:
â”‚   â”‚                   cb.setVisible(True)
â”‚   â”‚               for widget, _ in self.category_widgets:
â”‚   â”‚                   widget.setVisible(True)
â”‚   â”‚               return
â”‚   â”‚   
â”‚   â”‚           # Filter
â”‚   â”‚           for cb in self.checkboxes:
â”‚   â”‚               matches = search in cb.tag_text or search in cb.category.lower()
â”‚   â”‚               cb.setVisible(matches)
â”‚   â”‚   
â”‚   â”‚           # Hide empty categories
â”‚   â”‚           for widget, name in self.category_widgets:
â”‚   â”‚               visible = sum(1 for c in widget.findChildren(QCheckBox) if not c.isHidden())
â”‚   â”‚               widget.setVisible(visible > 0)
â”‚   â”‚   
â”‚   â”‚       def update_ui_state(self):
â”‚   â”‚           """Update selection display"""
â”‚   â”‚           selected = [cb.text() for cb in self.checkboxes if cb.isChecked()]
â”‚   â”‚           count = len(selected)
â”‚   â”‚   
â”‚   â”‚           if count > 0:
â”‚   â”‚               preview = ", ".join(selected[:8])
â”‚   â”‚               if count > 8:
â”‚   â”‚                   preview += f" (+{count - 8} more)"
â”‚   â”‚               self.selection_label.setText(f"Selected ({count}): {preview}")
â”‚   â”‚               self.apply_btn.setText(f"Apply {count} Tags")
â”‚   â”‚           else:
â”‚   â”‚               self.selection_label.setText("No tags selected")
â”‚   â”‚               self.apply_btn.setText("Apply Selection")
â”‚   â”‚   
â”‚   â”‚       def clear_all(self):
â”‚   â”‚           """Clear all selections"""
â”‚   â”‚           for cb in self.checkboxes:
â”‚   â”‚               cb.blockSignals(True)
â”‚   â”‚               cb.setChecked(False)
â”‚   â”‚               cb.blockSignals(False)
â”‚   â”‚           self.update_ui_state()
â”‚   â”‚   
â”‚   â”‚       def get_selected_tags(self) -> List[str]:
â”‚   â”‚           """Return selected tags"""
â”‚   â”‚           return [cb.text() for cb in self.checkboxes if cb.isChecked()]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def main():
â”‚   â”‚       """Test dialog"""
â”‚   â”‚       app = QApplication(sys.argv)
â”‚   â”‚       app.setStyle("Fusion")
â”‚   â”‚   
â”‚   â”‚       dialog = TagSelectorDialog("Pop, Electronic, Dark")
â”‚   â”‚   
â”‚   â”‚       if dialog.exec():
â”‚   â”‚           print(f"Selected: {', '.join(dialog.get_selected_tags())}")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   if __name__ == "__main__":
â”‚   â”‚       main()
â”‚   â”‚   
â”‚   â””â”€â”€ windows_dll_fix.py  [Mod: 2026-02-14 04:48:29]
â”‚       Content:
â”‚       """
â”‚       CRITICAL: This module MUST be imported FIRST
â”‚       Configures Windows environment to prevent DLL loading errors
â”‚       """
â”‚       
â”‚       import os
â”‚       import sys
â”‚       
â”‚       # Fix DLL loading issues
â”‚       os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
â”‚       os.environ["OMP_NUM_THREADS"] = "4"
â”‚       os.environ["MKL_NUM_THREADS"] = "4"
â”‚       
â”‚       # Add Windows DLL directories
â”‚       if sys.platform == "win32":
â”‚           try:
â”‚               os.add_dll_directory(r"C:\Windows\System32")
â”‚               os.add_dll_directory(r"C:\Windows\SysWOW64")
â”‚           except (AttributeError, OSError):
â”‚               pass
â”‚       
â”‚       print("[DLL FIX] Environment configured for Windows")
â”‚       


============================================================
SECTION 2: DIRECTORY STRUCTURE
------------------------------
AGANCY/
â”‚   â”œâ”€â”€ DRAFTS/  [Mod: 2026-02-14 05:31:52]
â”‚   â”‚   â””â”€â”€ auto_save_20260214_053152.json  [Mod: 2026-02-14 05:31:52]
â”‚   â”œâ”€â”€ PRODUCER_STRATEGIES/  [Mod: 2026-02-14 04:48:40]
â”‚   â”‚   â”œâ”€â”€ 1_Narrative_Concept.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â”œâ”€â”€ 2_Brand_Identity_Hits.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â”œâ”€â”€ 3_Circadian_Ambient_Flow.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”‚   â””â”€â”€ 4_Mythic_Journey.json  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ agency_styles.py  [Mod: 2026-02-14 08:54:18]
â”‚   â”œâ”€â”€ Album_Post_Processor.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ Blueprint_Executor.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ EnhancedModelScanner.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ human_evaluation.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ IndividualSongRenderer.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ lmstudio_controler.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ Orphio_Command_Center2.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ orphio_config.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ orphio_engine.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ orphio_schema.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ OrphioMusicAgencyStudio_______start.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ OrphioProductionStudio___________COMPLETE.py  [Mod: 2026-02-14 08:55:27]
â”‚   â”œâ”€â”€ OrphioProductionStudio___________COMPLETE2.py  [Mod: 2026-02-14 08:44:09]
â”‚   â”œâ”€â”€ RUN_FULL_ALBUM_PIPELINE___________start.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ SYSTEM_OVERVIEW.md  [Mod: 2026-02-14 08:46:37]
â”‚   â”œâ”€â”€ SystemSetupChecker.py  [Mod: 2026-02-14 04:48:29]
â”‚   â”œâ”€â”€ tags.json  [Mod: 2026-02-14 06:38:03]
â”‚   â”œâ”€â”€ tagSelector.py  [Mod: 2026-02-14 07:07:12]
â”‚   â””â”€â”€ windows_dll_fix.py  [Mod: 2026-02-14 04:48:29]
